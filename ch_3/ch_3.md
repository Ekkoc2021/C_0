# ch3

printf函数中占位符如果数值没有给出，会使用内存中任意值代替。

进制表示：
- 0x/0X 开头表示16进制 printf输出 %x (携带前缀%#x)
- 0 开头表示8进制   printf输出 %0
- 0b/0B 二进制 printf输出%b
- 没有任何开头 10 进制

## 整型 int
长度(sizeof(类型)==>统计数据长度,单位为字节):
- int: (64位机器)32位,至少16位
- long int (long) :(64位机器)32位,至少32位
- long long int (long long): (64位机器)64位
- short int (short) : (64位机器) 16位,至少16位

long不会比int短,int不会比short短,当程序需要移植,同时对数据有要求时,应该考虑不同机器下的数据类型长度是否会带来影响.long类型会减慢计算.

默认常量如果常量比较大,会根据大小依次被视为int类型,long int类型,unsigned long类型,long long 类型,unsigned long long类型.类型不同赋值过程存在隐式转换的过程.

如果希望常量是知道的类型可以在其后缀加上:l,ll,ull,ul等字符.

八进制,十六进制,int , unsigned int , ....

输入输出说明符:%d

## 字符类型
char 类型 占1字节

赋值:可以单引号的单个字符,也可以int类型的数字(八进制:\0,十六进制:\xhh )

输入输出说明符: %c
## 可移植的类型:inttypes.h
inttypes.h文件中包含已经定义了确切的长度的int类型
还提供了对应的输入输出的说明符号,如:PRId16==>打印16位

```
printf("me16=%"PRId16"\n",&me16);
```

如:
- 只关注确切位数:int8_t 
- 关注最小位数:int_least8_t
- 使用计算速度最快且满足最小位数:int_fast8_t

## 浮点数

常量(e后面正号可以省略),默认是double类型,赋值给float会存在隐式转换(性能损失,尽管非常小)
- .008
- 8e-3
- 0.008
- 8E-3

赋值:可以是常量运算后的值,也可以直接常量赋值

精度 float(32位) < double(64位) < long double(至少和double一致)

输入输出说明符: 
- %f 十进制输出double,float
- %e 指数计算法输出double float (%E与%e等价,系统如果支持C99的十六进制格式浮点数则还可以用%a和%A)
long double类型,在输出double和float的说明符加上L

## 浮点数的上溢与下溢
上溢:输出为inf,infinity,表示无穷大
下溢:超出精度外的小数位被截断
NaN/nan表示不是一个数字,asin输入不能大于1,否则返回NaN

## 浮点数误差
浮点数并不能准确的表示某些十进制的数,可能会导致运算出现误差.

## 复数和虚数
需要包含complex.h头文件
类型(指明实部与虚部的数据类型):
- float_Complex 
- double__Complex
- long double__Complex
通过 crealf() 和 cimagf() 函数，我们可以获取虚数的实部和虚部。

## _Bool类型

c99引入了该类型,占一个字节,0表示false,1表示true,无法直接赋值false和true

可以使用stdbool.h这个头文件,引入bool这个类型,可以赋值bool为false和true,bool同样也是占用1个字节

两种类型都是0表示false,大于0表示true

即使你赋值给_Bool类型非0的数字,都是1字节存储,也会被当做是1来对待

## 数据类型总结
以上的类型,除了复数,底层都是数值,这就意味着都能通过数值的常量进行赋值.

不同类型的常量赋值会存在一个截断的风险,存在精度的丢失,同时也会有略微的性能损失(可以忽略不计)

## printf函数
格式化输出字符串,第一个参数为字符串,后续参数为会按照顺序填充到字符串的说明符中,printf函数返回值是成功打印字符数量,打印失败返回-1.

说明符与变量的类型不对等的时候,并不会出现截断的情况,而是显示垃圾值.
说明符数量大于变量参数,则多余的说明符号会输出内存中随机值
而如果是变量参数多余说明符,则多余的会被丢弃

大多数情况下的编译器不会对printf函数的参数检查,unix的语法检查程序会查出printf函数的错误.

**刷新输出,print会将数据先写入缓冲区,再写入屏幕.**
以下会导致数据从缓冲区写到屏幕

1. 缓冲区满了
2. 换行符号
3. 输入内容

这个机制可能会导致程序出现和预期不一样的行为.