# ch9

声明位置(声明的函数称为函数原型)要在使用之前,声明可以在函数体之内,也可以在函数之外

需要函数原型的原因:使得编译器编译第一个调用函数的语句之前向其表明该函数的用法(函数类型,函数参数)

可以不使用函数原型而去直接实现函数,只要这个实现在调用之前也能达到函数原型的效果,这样可能做会使得代码可读性变差.

ANSI C 规范:声明时可以不用指定函数的形式参数(最好指定),一旦指定必须与函数原型一一对应.函数的类型(返回值类型)是必须指定的

没有指定参数,但是函数的具体实现带参数,使用时传入缺少的实际参数编译和运行都不会报错,但是结果是无法预测的

实际调用的函数(如main函数)会将被调用函数需要的参数放到堆栈中(编译通过),假如现在有一个函数原型需要两个参数,而声明时没有没有指定形参,调用时只指定了一个实际参数,被调用的函数会根据需要从堆栈中按照声明的数据类型依次读取两个数据给这个形参赋值,只传入一个数据,那么第二个数据值将是不可预测的,但是也不会没有,从而运行不会报错

ANSI标准需要声明的同时说明所使用的参数类型

## 无参数和不确定参数

```
void p(void); // 无参数

void p2(char *,...); //第一个参数是一个字符串,剩下参数不确定

```

不确定参数的使用:所有的参数在调用时都会放在一个堆栈里面,使用可变参数时需要考虑可变参数起始的地址和获取后可变参数的类型,可以通过c提供的`stdarg.h`这个头文件提供的宏获取可变参数.

- va_start(ap, last_arg)：初始化可变参数列表。ap 是一个 va_list 类型的变量，last_arg 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 ap 指向可变参数列表中的第一个参数。

- va_arg(ap, type)：获取可变参数列表中的下一个参数。ap 是一个 va_list 类型的变量，type 是下一个参数的类型。该宏返回类型为 type 的值，并将 ap 指向下一个参数。

- va_end(ap)：结束可变参数列表的访问。ap 是一个 va_list 类型的变量。该宏将 ap 置为 NULL。

使用:在函数内定义一个va_list的变量,用va_start去设定可变参数的起始地址,通过va_arg获取可变参数,va_end清空设置好的va_list变量

```
#include <stdarg.h>
 
double average(int num,...)
{
 
    va_list valist;
    double sum = 0.0;
    int i;
 
    /* 为 num 个参数初始化 valist */
    va_start(valist, num);
 
    /* 访问所有赋给 valist 的参数 */
    for (i = 0; i < num; i++)
    {
       sum += va_arg(valist, int);
    }
    /* 清理为 valist 保留的内存 */
    va_end(valist);
 
    return sum/num;
}
```

## 递归

c函数支持递归
- 代码简洁

尾递归:递归调用放在return语句之前

递归的缺点
- 可读性差
- 资源消耗大

c中所有函数都是平等的,main函数也可以递归,但是很少这么做!

## 多源代码文件程序的编译
将多个源文件一起编译成一个文件

### UNIX
make命令
```
cc file1.c file2.c
```

### Linux
安装GUN C编译器gcc
```
gcc file1.c file2.c
```

### windows
创建一个工程,所有文件都放在工程文件夹内
- 源文件 `.c` 结尾
- 头文件 `.h` 结尾(**头文件不能包含在工程之中!!-_- 没明白!**)

## 头文件

### c语言编译阶段

**预处理**

处理以“#”号开头的预处理指令如包含#include,宏定义制定#define等.如将头文件中的定义添加该源文件
生成一个`.i`后缀的文件<br>
linux下命令
```
gcc -E file.c -o file2.i
```

**编译、优化**

`.i`文件到`.s`.<br>编译:通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。<br>优化:对中间代码进行优化(比较复杂),优化的目的是为了让代码更加的高效<br>
linux下命令
```
gcc -S file.i -o file2.s
```

**汇编**

中间代码(都是汇编代码)翻译成目标机器指令的过程<br>
linux下命令
```
gcc -c f.s -o f.o
```

**链接**

得到`.o`目标文件并不能立即就被执行,被编译的源文件中可能引入了其他源文件中定义的符号,运行时需要使用.

- 静态编译 : 所用到的函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。

- 动态编译 : 函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。

动态编译使得可执行文件更小!编译过程包含两种方式<br>
linux下命令
```
gcc test.o -o test
```

### 头文件
用于声明函数原型,在预处理阶段引入到需要使用的源文件的开头
- 函数原型
- 常量

使用
```
#include "myheader.h" // 在源文件所在目录搜索
#include <stdio.h> //在库文件所在目录搜索
```
双引号""包含头文件适用于自己编写的头文件或相对路径下的头文件，而使用尖括号<>包含头文件适用于标准库的头文件或系统级别的头文件。

windows下c工程的一般目录结构 
```
project/
    ├── src/
    │   ├── file1.c
    │   ├── file2.c
    │   └── ...
    ├── include/
    │   ├── header1.h
    │   ├── header2.h
    │   └── ...
    ├── lib/
    │   ├── library1.lib
    │   ├── library2.lib
    │   └── ...
    ├── bin/
    │   ├── executable.exe
    │   └── ...
    └── README.md
```
引入头文件
```
#include "../include/header1.h"
```

## 地址运算符: &

输出说明符号:%p 

取地址:&i 

## 指针简介

指针:数值为地址的变量

获取一个变量的地址:&i  获取变量i的地址值,返回一个对应类型的指针变量.<br>奇怪的知识:当i是int类型时,&i可以赋值给int类型变量(至少在我的机器上编译是通过了的,虽然有警告),其他的却不行

获取一个地址内保存的值:*p (*为间接运算符)

指针声明: `type * name;`

修改指针地址所保存的值: `*p=常量;`

修改指针地址: `p=地址;`

