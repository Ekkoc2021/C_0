# ch12

## 存储类

c用作用域,连接,存储时期来定义存储类

作用域

- 代码块作用域:注意循环,函数等的代码块范围
- 函数原型作用域:范围变量定义到原型声明末尾
- 文件作用域:函数之外的变量(全局变量),作用范围为定义到文件结尾
- 函数作用域:goto对函数中任何地方可见

变量和函数可以具有不同的链接属性。链接属性决定了这些标识符在程序的不同文件之间如何链接和共享。

链接

- 外部链接:具有文件作用域且没有被声明为static的变量
- 内部链接:具有文件作用域且被声明为static的变量==>文件私有
- 空链接:代码块作用域或函数原型作用域

存储时期

- 静态存储时期:变量运行期间一直存在==>具有文件作用域的变量(与static无关)
- 自动存储时期:进入代码块则分配内存,退出则释放

5种存储类

- 自动
- 寄存器
- 具有代码块作用域的静态
- 具有外部链接的静态
- 具有内部连接的静态

| 存储类             | 时期 | 作用域 | 链接 | 声明方式                    |
| ------------------ | ---- | ------ | ---- | --------------------------- |
| 自动               | 自动 | 代码块 | 空   | 代码块内                    |
| 寄存器             | 自动 | 代码块 | 空   | 代码块内,使用关键字register |
| 具有外部链接的静态 | 静态 | 文件   | 外部 | 函数之外                    |
| 具有内部连接的静态 | 静态 | 文件   | 内部 | 函数之外,使用关键字static   |
| 空连接的静态       | 静态 | 代码块 | 空   | 代码块内,使用关键字static   |

## 自动存储变量

代码块内不需要额外声明,使用 `auto`关键字使得意图更加清晰:覆盖一个外部的函数定义,该变量无法改变为其他存储类

```c
int main(void){
	auto int p;
```

需要注意代码块的定义

- 使用{}
- 循环或者if语句的一部分,即使没有{},也会被认为是一个代码块==>c99新规则,如果不支持需要 额外设置 `gcc  -std=c99 filename.c` 为filename.c文件设置,基本不需要!!

自动变量初始化

- 自动变量除非显式初始化,否则不会自动初始化

## 寄存器变量

该变量可能存放在cpu寄存器中,或者更快的可用内存中,访问更快

**建议**编译器尽可能地将该变量存储在寄存器中，以加快对该变量的访问速度。但也只是建议，也就是可能不存放在寄存器内，同时你还无法获取地址！

**大多放在寄存器内,所以无法获取地址**

```c
register int quick = 10; // 将 quick 变量建议存储在寄存器中
// 下面的语句尝试获取 quick 变量的地址，会导致编译错误或警告
int *ptr = &quick;

```

## 具有代码块作用域的静态变量

静态==>位置固定不动了

同一个代码块访问该变量的地址都是不变的,变量也只有在编译该代码块时被初始化

只被初始化一次,没有显式的初始化值,则为0

每次执行对应代码块时,直接跳过初始化,原因是静态变量和外部变量在程序调入内存时就已经就位了,而放在对应的代码块内,则是告诉编译器只有该代码块能过对改静态变量可见

函数的参数不允许使用static

## 具有外部链接的静态变量

使用 `extern`关键字声明外部变量静态变量使得语义更加清晰,如果是使用的变量在其他文件已经定义,则一定要使用 `extern`关键字

首次声明时不能使用 `extern`,首次声明为定义声明,编译器会为其分配内存,而使用 `extern`关键字则只是引用声明,**引用声明不能进行初始化!!!**

声明数组时后续再次引用时的长度都可以省略掉

代码块内获知外部变量:

- 使用 `extern`声明获知外部变量,对外部声明顺序没有要求==>声明使得可读性更好
- 默认使用==>要求外部变量声明在代码块之前

没有显式初始化则为0

外部变量的数组不可以为变长数组

c99要求局部变量命名最长为63,外部变量(函数也包括在内)命名最长只能为31

对于 `extern`关键字的适用与否!取决于编译器,有的编译器如果包含初始化的外部变量不超过一个的话,允许多文件声明该变量而不使用extern,如何包含则当做变量定义!

## 具有内部连接的静态变量

使用 `static`修饰,只能被自己文件内函数使用

```c
static int s=1;
```

使用 `extern`关键字再次声明任何具有外部文件作用域的变量==>对于static的变量也能同样使用

多文件下外部链接和内部链接的区别才会显得重要!


## 空链接的静态

在函数体内,使用 `static`修饰,不会被释放

第二次执行的不会进行初始化,就好像是只能被这个函数访问的一个全局变量.

## 存储类说明符号

- auto : 具有自动存储时期
- register : 具有代码块作用域的变量,寄存器
- static : 代码块作用域,静态存储,外部声明时具有内部链接
- extern : 声明一个已经在别处声明过的变量
- typedef 与内存存储无关,但是语法原因归入此类

不能在一个声明中同时使用多存储类声明符号

## 函数与存储类

函数也具有存储类,使得函数能够被其他文件所使用

## 存储类的选择

尽可能的选择自动存储==>降低耦合度

## 随机函数的实现和猜数游戏

现成的随机数函数rand()在 `stdlib.h`头文件中

实现随机函数

```c
#include <time.h>
/*
实现rand()函数==>返回伪随机整数
使用time.h头文件获取当前时间
*/

static char isSet = 0;
static int se = 1;
int setSend(int seed)
{
    extern int se;
    extern char isSet;
    se = seed;
    isSet = 1;
    return isSet;
}

int randInt()
{
    extern int se;
    if (isSet)
    {
        se = se * 9999823 + 34234;
    }
    se = ((int)time(NULL)) * 9999823 + 34234;
    isSet = 1;
    return (int)(se);
}
```

使用随机函数实现猜数游戏

```c
#include <stdio.h>
#include <math.h>

extern int randInt();
int main()
{
    puts("猜数字游戏!输入非数字结束游戏!");
    int num = randInt();
    // printf("%d", num);
    printf("这个是数字是一个%d位数!\n", (int)(floor(log10(num)) + 1));
    int yourGuess;
    while (0 == 0)
    {
        printf("请输入你的数字: ");
        if (!scanf("%d", &yourGuess))
        {
            printf("这个数字是:%d!\n", num);
            break;
        }
        if (yourGuess == num)
        {
            printf("恭喜猜对了!这个数字是:%d!\n", num);
            break;
        }
        if (yourGuess < num)
        {
            puts("你猜小了!再大点!");
            continue;
        }
        if (yourGuess > num)
        {
            puts("你猜大了!再小点!");
            continue;
        }
    }
}
```

gcc多文件编译

```
gcc GuessGame.c rand.c -o GuessGame.exe
```

## 动态内存分配:malloc和free

5种存储器类:自动决定了作用域和存储时期

c语言允许程序员自己管理内存,可以使用malloc去在程序运行期间分配内存,最后使用free释放内存,这两个函数都在stdlib.h头文件中声明

```c
void *malloc(size_t size); //分配size个字的内存,并返回分配的指针,内存不够返回null指针
void free(void *ptr); //释放内存
void *realloc(void *ptr, size_t size); //重新设置已经malloc的ptr
指针的长度,重新分配内存,释放原内存,如ptr=null则等价于malloc
void *calloc(size_t num_elements, size_t element_size); // num_elements元素的数量,单个元素的大小


```

自动存储变量是存放在栈上的,然而栈并不是无限大,使用malloc分配的内存在堆中,堆比栈要大当我们需要大内存时应该使用malloc去分配内存

- 内存泄漏 : malloc的内存没有即使使用free释放,导致系统无法回收
- 内存溢出: 访问超过范围的内存

使用技巧

- 当申请内存失败的时候可以使用exit(EXIT_FAILURE)去提取结束运行,这个函数也是stdlib.h中的

可以认为程序将可用内存分为3个独立的部分

- 具有外部链接的,具有内部链接的以及具有空链接的静态变量的内存==>伴随程序开始到结束
- 自动变量的内存==>放在栈上,自动释放
- 动态分配的内存==>程序员自己释放

## 类型限定词 const

```c
const int a; //a的值为只读模式==>好像初始值都为0,c++中必须初始化
const int b=3; //这样初始化是允许的

const int *p;//表示p所指向地址存放的值不可以通过p指针去修改,也就是*p不可改,p可改
int *const p; //p指针的值不可改

extern int const d; //声明使用作用域为文件的变量
// 个人觉得const放在类型之后语义会更加清晰一些
```

## 类型限定词 volatile

`volatile` 表明某个变量是易改变的,这个可以方便编译器优化

某些时候当某个变量被多次使用而没有改变它的值,编译器在两次使用期间会将其放到寄存器中方便访问,但实际上有一些变量地址的数据会被其他代理改变:比如用来接收其他计算机的信息

c99之前是不会放到寄存器(这个过程称为缓存)的过程的,缓存是一个很好的优化方式,c99之后引入了 `volatile`

一个值可以同时被const和volatile修饰的==>const只是代表着不能通过当前声明的变量名称去修改值,但是这个值也许本身就不是const类型,可以在其他地方进行修改!

```c
int volatile a; //a的值是易变的
int volatile *p;  //p指向的地址的存放的值是容易改变的
int * volatile p2 ; // p2指向的地址是容易改变的
```

## 类型限定词 restrict

`restrict`是C语言中用于向编译器传达指针的约束条件，以便优化代码。使用 `restrict`关键字可以告诉编译器，一个指针是唯一访问某个内存区域的，并且在其生命周期内不会被其他指针修改，这样编译器可以进行更有效的优化。

只能用于指针!一般在在追求性能的程序里面使用,编译器不会检查你的指针是否满足使用restrict的条件,所以使用不当会导致意想不到的行为

```c
int * restrict a; // a指向的地址只有a知道
*a+=100;
// 一些和a无关的代码
*a+=2;
//最终优化成了 *a+=102;
```

## 类型限定词一些奇怪的写法

```c
void f1(int * const a1,int * restrict a2);
void f2(int a1[const],int a2[restict]);
//两个函数写法是等价

void f3(int a1[static 20]); //这样只是表示这个数组至少有20个,编译器利用这个信息进行优化
```

end
