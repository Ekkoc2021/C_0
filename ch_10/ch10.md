# ch10

## 数组

声明: `type name[length];` length只能是常量,c99标准不允许length为变量(我的编译器能编译通过,并且能运行,变量可以作为长度)

初始化,c语言对于一些变量如果没有赋予初始值,如果原来内存单元有对应的数字那么可能会影响程序行为.

没有经过初始化的数组的初始值是不确定的,初始化后的数组,即使有的没有赋予初始值编译器也会设置默认初始值,int类型数组默认为0

常量数组: `const type name[length];```

如果初始化的项目个数大于给定的大小,编译报错,可以如下处理:

```c
int i[]={1,2,3}; //数组长度由项目个数确定
```

有时候我们只想要对在数组一些特定位置的项目进行初始化

```c
int arr[6] = {[5] = 222, [2] = 3}; //指定初始化某些位置的项目
int arr3[6]= {[3]=222,3,4}; //后续的3,4会赋值给第5个元素和第6个元素
```

为数组赋值

```c
arr[1]=99; //c中的数组不会检查是否越界,超过界限的索引也会有值但是值是不确定的
```

获取数组长度的方法

```c
int length=sizeof(arr)/sizeof(int) //假设arr数组是int类型的
```

多维数组

```c
int arr[6][7]; //声明了一个二维数组,长度为6的数组里面的每个元素都是一个长度为7的数组
```

多维数组的初始化

```c
int a[2][3] = {{1, 2},{3, 5}}; //是拷贝的形式,只要被拷贝的数组长度不大于所定义的数组即可

int b[2][3]={1,2,3,4,5,6}; //还可以这样初始化,只要项目个数小于数组项目个数即可
```

## 指针和数组

数组标记实际上是一种变相使用指针的形式

数组名称实际上是数组首元素的地址的指针,所以c语言中不能够将一个数组赋值给另外一个数组

但是数组并不能像指针那样进行自增自减,可以参与运算

指针运算:指针每加1都会指向该类型数据的下一个地址,一般机器都是按照字节寻址,指针+1等价于对指针的值加上它指向的对象的字节的大小

但是还是有区别,数组是能够使用sizeof计算出数组大小的,而指针使用sizeof只能计算出该指针类型占用大小

在一个系统中所有指针的sizeof运算结果都是一致的

```c
//对于数组a或者指针a下面是等价的
a+2==&a[2]; //true
*(a+2)=a[2]; //true

```

在函数原型中使用数组作为形式参数时,尽量不要用指针取代数组,提高可读性

在c中数组作为参数时传递的都是地址值,函数内修改数组会影响到原数组

++和*的运算级别是等同的,运算顺序是从右往左

## 指针操作

加法:不允许指针之间相加

递增

递减

相减:大指针-小指针

指针间不能相加,也不能进行乘法运算

指针一定要进行初始化,因为指针没有初始化后数值是随机的,指向一个随机的地址,对这个地址所在的数据进行修改可能不会造成系统崩溃,但是对程序可能是致命的

## 数组拷贝

c语言数组作为函数参数,函数对数组的操作会影响到原数组,通过数组拷贝可以保护

## 常量指针

常量指针所指向的地址的存放值不允许修改，允许指针值被修改。只是不允许通过该变量去修改存放的值,如果有其他途径这是被允许的

普通变量==>可以变成常量  常量==>不可以变成普通变量

常量变量不能将其地址赋予普通指针

常量数组无法赋值给普通数组

## 多维数组指针

对于一个二维数组arr

arr是首个元素的地址,也就是说arr=&arr[0]

arr[0]是第一个数组的起始地址,也就是说arr[0]=&arr[0][0]

二维数组,其实就是存放了数组的指针

```c
**arr==arr[0][0]; //true *arr=arr[0] 而arr[0]一个数组的起始指针 从而 **arr=arr[0][0]
```

arr+1 和arr[0]+1是有区别的,arr存放的数组,其单位是一个数组,arr+1=arr[1]

arr[0]+1=arr[0][1]

## 指向多维数组的指针

```c
int (*ptr)[2]; //指向长度为2的数组
int *ptr[2]; //指针类型的数组,一个长度为2的指针数组
// []的运算高于*,ptr先与[]进行运算,表示包含两个某种类型元素的数组,int*表示为int类型指针
// 而 添加了括号的表示先进行*ptr运算(云里雾里的,当做定义背下来了)
int(*(*ptr2)[2])[3]; //开始套娃
int i2[2][3] = {{1, 2, 3}, {11, 22, 33}};
ptr2 = i2;

```

## 指针的兼容性

指针的类型是很严格的,int可以无缝转换为double,但是指针却不行.

多级指针

```c
int **p; //指向指针的指针,这说明指针指向的地址最终是一个int类型数值

int const **pp1; //pp指向的是一个指针的地址,表明**pp1的值一旦指定不可再更改,但是我们可以改*pp1的值
int *p2; 
pp1=&p2; //符合常量的规定,但编译会报这样的警告warning: initialization discards 'const' qualifier from pointer target type

// 如果这样赋值,那么可以通过p2这个指针去修改一个常量变量
const int n=13;
*pp1=&n; //**pp1不可改,无法修改n的值,这一步是正常的

*p2=10;//&p2=pp1的,也就是说p2=*pp2,p2的值和n的地址值是相同的,此时常量n的值被修改了


int * const *pp3; //也是一个指向指针的指针,表明*pp3初始化后不能直接通过*pp3再去修改值
/*
 	重新认识一下const: 初始化后不能直接通过该变量修改值
*/

```

可以通过指针间接修改一个常量的值,至少我的编译器是能正常编译运行的,但谁会去钻这个空子呢?

## 函数和多维数组

c语言中在函数定义形式参数时,指定二维数组至少要指定第二维度的大小

编译器会将数组转换为指针,所有的数组取值都会转为指针的运算,不指定第二维度,则无法确定运算的单位大小,只要保证编译器知道指针运算单位的大小,都是合法的

```c
void func1(int a[]); //这种声明是允许的
// void func1(int a2[][]); //不允许,a2+1,1的单位无法确定
void func2(int a2[][2]); 
// 函数的形式参数允许这样声明,但是不允许不初始化这样声明,这是好理解的,这样声明,不知道要分配多少内存

void func3(int a2[3][2]);  //这样声明3会被忽略,这里的数组被解释为指针
//我们在函数体内直接声明的数组a[3][2],可以通过sizeof(a) / sizeof(a[0])计算出3,
//sizeof(a[0]) / sizeof(a[0][0])计算出2,转为指针后,sizeof(a) / sizeof(a[0])将无法正确计算
//在函数中使用数组总是要传入一个长度
//函数在处理多维数组,还可以转成一维数组去处理,本质上的多维数组还是一维的,我们只要数组第一个的地址就行
```

## 变长数组(变量)

**c99引入了变长数组,运行变量作为数组的长度**

常规数组都是静态存储分配的(常量指定长度,编译器知道怎么做),变长数组允许动态分配存储单元

变量作为数组长度的要求

- 必须自动存储类的,也就是只能在函数内作为函数形参声明
- 声明时不可以初始化

c语言中,声明函数的形式参数,可以使用已经声明形式参数的

```c
int sum(int r,int c,int ar[r][c]);
//c99标准规定,可以省略原型中的名称
int sum(int,int,int ar[*][*]);
// 虽然指定了r,但实际上ar依然是一个指针,如果你不想要指针,可以将形参ar放到函数体内
```

## 复合文字

数组常量的定义,5是int类型的文字...

```c
(int [2]){1,2}  //数组类型的常量
(int []){1,2}  //不声明长度,让编译器计算长度
//数组是不能够赋值给另外一个数组的,但是可以通过指针去保存
int *ptr=(int []){1,2};
```
