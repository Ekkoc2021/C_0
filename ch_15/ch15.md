# ch15

# 位运算符

位运算符=>计算机显示的补码,位运算符操作的也是补码,要知道具体数值需要转为原码

原码==取反(符号位保留)==>反码==加1==>补码

正数原码就是补码

- `~ `按位取反 ~1=-2
- `&` 按位与
- `|` 按位或
- `^` 按位异或 相同为0,不同为1

## 用法:掩码

用 & 实现掩码:只保留某些位的数值

0表示遮挡的位置,只有为1的时候才能看得见,遮挡位为0,其余为1

修整某个字节

## 用法:打开位

用 | 来实现:不影响其他位使得某位为1

让打开设置为1,其余不变

## 用法:关闭位

不影响其他位的情况下使得某位为0

用&来实现,让关闭位设置为0,其余为1,也就是掩码的反码

## 用法:转置位

使得特定位取反,使用异或实现 ^

相同为0,不同为1==>特定位为1,实现取反

## 用法:查看某一位的值

使用一位的掩码,判断操作后是否等于掩码即可知道该为是否等于1

# 位移运算符

同样也是操作补码

- `<<` 左移动 相当于 x2的n次幂
- `>>` 右移动 除以2的n次幂

# 位字段

```c
struct bit_field{
	unsigned int b:1; // 长度为1
	unsigned int c:2;// 长度为2
};
// bit_field只能是整数类型,负数需要考虑符号位
//计算实际结构体占用的位数需要考虑编译器的数据对齐（alignment）和字节对齐（padding）规则

//位域边界对齐:前一个类型或当前长度,满足所有位域字段容量,则所有成员在一个字段容量内,超过了,编译器会强制移动到下一个字段(单个位域长度不应该大于类型的长度)

struct bf2{
	unsigned short a:15; //15位 short为16位
	unsigned short b:15;  // b会主动到下一short类型上,a与b留下一个空白位
	unsigned short :1; // 未命名的字段宽度主动填充空白位
	unsigned short c:12 ; // b与c留下一个空白位
	unsigned short :0; //强制下一个字段对齐到新的16位上
	unsigned short d:2; //够放,但是也被强制对齐
}; //总长度 为 16x4=32位

//一般结构体总长度会和某个数据类型长度一致,可以再包装到一个联合中,使得同一个数据,不同的展示形式
// 当然也可以使用int指针实现重新映射
union ub{
	struct bf2 b;
	int  c; //让b以int类型类型完全展示,方便处理
}

// 位字段配合union来使用时可能会造成不可移植,有的系统位字段默认装入从最低位开始装入,有的却不是
// 不同的装入顺序,可能会导致位处理时程序错误
// 位域如果赋值如果长度超过会出现截断
```
