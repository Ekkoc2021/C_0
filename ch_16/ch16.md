# ch16

编译之前,先由预处理器检查程序

预处理之前

- 源代码中出现的字符映射到源字符集==>要知道文件的编码字符
- 删除反斜线后紧跟换行符的==>转为一行
- 将文本划分成预处理的语言符号序列和空白字符以及注释序列==>如:空格取代注释
- 最后进入预处理阶段

## 明显常量:#define

- 允许#之前有空格和制表符
- #之后也允许有空格
- 可以出现在任何地方,其作用域为定义位置到文件结尾
- 声明从#号开始到第一个换行符号为止==>预处理器会删除反斜线和换行符,所以可以用\使得其扩展到多行

```
#define 缩略语(宏) 主体(替换列表)

宏的部分不能够有空格,一般全部大写,遵循c变量命名规则
预处理在程序中发现了宏的实例后,会用替换列表去替换去替代宏==>这个过程称为宏展开
宏展开无法替换字符串常量,如:"HELLO world"中的HELLO是定义的宏,但是无法被替换
```

```c
const int a1 = 2;
// static int ar[a1]; //语法错误
#define length 2
static int ar[length] //正确
```

可以使用#undef去解除定义然后重新定义常量==>再次使用#define定义同一个宏:ansi标准只允许新定义与旧定义完全相同

使用参数

```c
#define 宏定义(参数1,参数2...) 替换主体
// 宏只是进行了替换,替换主体和参数如果是运算式,需要考虑替换后的运算的优先级
// 尽量不要在宏参数中使用自增自减==>复杂的运算可能会带来意想不到的结果

// 同时替换主体的字符串中如果包含参数,是不会发生替换的
// 字符串化:如果你希望参数能够在主体的字符串中使用宏,可以这样:
#define P(x) "hello"#x"world!"
```

`##`运算符:粘合剂

```c
#define P(x) a ## n
int P(1); //int a1;
```

可变宏:`...`和 `__VA_ARGS`

```c
#define PR(...) printf(__VA_ARGS__)
PR("%d %s", a, s);
```

使用宏还是还是函数?

宏只是替换,产生内联代码==>使得代码体积变大

函数还需要跳转到对应函数,同时也需要返回调用,比内联代码更费时间

简单函数都使用宏去实现

注意

- 对于替换中的每个参数都用括号去包裹,整体最好也使用括号去包裹
- 主体部分可以使用空格,但是宏命名不可以带空格
- 宏命名最好大写

## 文件包含: #include

将#include指令替换为对应的文件

```c
#include <stdio.h> 搜索系统目录==>一般标准库
#include "myfile.h" 当前工作目录下的头文件
```

头文件

- 明显常量声明
- 宏函数
- 函数声明
- 结构模板定义 struct
- 类型定义 typedef

## #undef指令

```
#undef LTIMT // 可以重新定义ltimt

```

## 条件编译

### #ifdef,#else和#endif指令

```c
#ifdef NAVIS
	#include "horse.h"
	#define STABLES 5
#else 
	#include "cow.h"
	#define stables 15
#endif
// 如果定义了 NAVIS则执行,否则执行
```

### #ifndef指令

```c
#ifndef NAVIS
	#include "cow.h"
#endif	#define stables 15
//如果没有定义NAVIS则执行,也可以和else连用

```

### #if和#elif

```c
// elif可以ifdef等连用,单通常不连用,在elif中有额外形式处理
#if defined(VAR)
	#include<stdio.h>
#elif VAR2==1
	#include<stdio.h>
#else
	#include<stdio.h>
#endif
```

## 预定义宏

```
__DATE__ : Mmm dd yyyy形式的字符串
__FILE__ : 当前源代码文件名称
__LINE__ : 当前行号,使用在哪里就在输出处于第几行,通常用于排错
__STDC__ : 设置为1表示遵循c标准
__STDC_HOSTED__ : 为本机设置环境为1,否则为0
__STDC_VERSION__ : 为c99时设置为199901L
__TIME__ : 源文件编译时间

```

## #line 和 #error

```c
// #line 用于重置__LINE__和__FILE__宏报告的行号和文件名
#line 1000
#line 10 "hello.c"

// #error 使得编译器发出一条错误消息
#error Not c99
```

## #pragma

通常可以用命令行参数修改编译器的某些设置,也可以用#pragma将编译器指令放置源代码中

```c
#pragma c9x on // c9x代表c99,启用对c99的支持
// 还可以用 _Pragma("c9x on")
```

## 内联函数

```c
inline void eatline(); //编译器会将函数代码取代使用内联函数的地方
```

- 定义和调用必须出现在同一文件中:编译器必须知道函数定义的内容(可以在头文件中定义)==>通常具有内部链接
- c只允许对函数进行唯一一次定义,但是对内联函数例外
- 内联函数没有单独的代码块,所以无法获得内联函数的地址,实际上可以获得,但是会产生非内联函数,内联函数不会在调试器中显示
- c语言与c++不同,可以混合声明内联函数定义和外部函数定义,在同文件中同时声明,调用函数的部分将由编译器来随意确定是使用内联还是外部
- 获取内联函数的地址,会使得编译器产生外部函数定义

## C库

- 自动访问:只需要编译,常见的库函数自动可用,但是应该声明函数的类型==>通常用头文件
- 文件包含:#include去包含头文件
- 库包含:有一些函数不在c库中,不会自动包含

数学库:math.h

通用工具库:stdlib.h

- exit() 和 atexit() 函数
- `qsort(void *base, size_t nmemb, size_t size, int( *compar)(const void *, const void *))`

诊断库:assert.h

- assert(z>=0) true 就不会报异常,正常执行,false后面代码都不会执行,且有输出

字符串库:string.h

- memcpy()==>复制数据,复制的字符串没有重叠
- memmove()===>有重叠一切都未知

可变参数:stdarg.h

- 函数参数列表首个参数不能是变参
- 定义一个 `va_list ap;` 用于存放可变参数
- 从ap中获取指定数据var_arg(ap,类型)==>返回数据,且ap指向下一个数据起始位置
- 用va_end(ap)完成清理,用于释放分配的内存

end
