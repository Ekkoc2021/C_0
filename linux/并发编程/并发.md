# 并发编程

## 多进程编程基础

进程控制块:存放进程信息,pid,用户,状态,优先级,文件描述符

进程类型

- 交互类型:shell下启动的程序,前台运行

- 批处理进程

- 守护进程（Daemon Process）:是在后台运行、脱离控制终端的一种特殊类型的进程。它们在 Unix-like 操作系统中常用于执行系统级任务、提供服务、监控资源等。守护进程通常在系统启动时启动，一直运行直到系统关闭。 

  ```
  无控制终端：守护进程不与任何控制终端关联，因此不会受到终端会话的影响。这意味着它们不会收到终端信号（如 SIGINT、SIGQUIT）。
  
  脱离会话组和进程组：守护进程通常会通过 fork() 创建子进程，然后在子进程中调用 setsid() 函数来创建新的会话组。这样可以使守护进程独立于终端会话和原始进程组。
  
  更改工作目录：守护进程通常会将当前工作目录更改为一个安全的目录，以防止卸载挂载点或其它问题影响到它的正常运行。
  
  关闭文件描述符：守护进程会关闭继承的文件描述符，以避免不必要的资源占用。特别是，标准输入、标准输出和标准错误输出通常会重定向到 /dev/null。
  
  处理信号：守护进程可能会处理一些特定的信号，例如重新加载配置文件、重新启动等。它们通常会注册信号处理函数来对信号作出响应。
  
  不使用交互式用户输入：守护进程不应该依赖于交互式的用户输入，因为它们不与终端交互。任何需要配置或控制的信息应该从配置文件中获取。
  
  记录日志：守护进程通常会将日志记录到文件中，以便跟踪运行情况、排查问题等。
  ```

会话与终端控制

**会话（Session）**：

一个会话是一个或多个进程组的集合，通常由一个前台进程组和一个或多个后台进程组组成。会话可以包含一个控制终端，但不是必需的。会话可以由一个终端启动，也可以在没有终端的情况下创建。

会话的一个重要特点是，会话中的一个进程组可以通过调用 `setsid()` 函数创建一个新的会话。这个新的会话会有一个新的会话ID（SID），并且进程组中的第一个进程会成为会话的首领。这在创建守护进程时非常常见。

**终端控制**：

终端控制是指进程与终端设备之间的交互。终端设备是一种提供了用户输入和输出功能的设备，通常是一个文本终端窗口。终端设备可以是实际的物理设备，也可以是虚拟终端。

在 Unix-like 系统中，进程通过打开一个终端设备文件（如 `/dev/tty` 或 `/dev/pts/*`）与终端进行交互。终端设备会接收用户输入，同时将输出显示给用户。控制终端通常与一个会话关联，控制这个会话中的前台进程组。

当一个终端设备关闭时，会话和终端控制的状态可能会发生变化。终端设备关闭时，会话中的所有进程会收到 `SIGHUP` 信号，这是一种终端断开连接的信号。这通常会导致会话中的进程终止，但它们可以通过处理 `SIGHUP` 信号来自行决定如何处理。

需要注意的是，守护进程通常会与任何终端断开连接，以避免受到终端的影响。这可以通过调用 `setsid()`、重定向标准输入输出、关闭文件描述符等方式实现。



进程状态

- 运行态
- 等待态
- 终止态:
- 死亡态

进程内容

- 正文段
- 用户数据
- 系统数据

程序==>存放在磁盘中计算机指令集合

进程==>执行的程序所有分配的资源



### linux进程相关命令

#### linux下查看进程

```
ps # 查看进程快照 ps -ef | more 筛选 ps -ef/aux | grep 筛选名称

top # 查看进程动态信息 htop 稍微好看一点,但是有的系统没有

/proc #详细信息
```

1. **ps 命令：** `ps` 命令用于显示当前正在运行的进程列表。它可以显示进程的状态、PID（进程标识符）、CPU 使用情况、内存使用情况等信息。

   常用选项：

   - `ps aux`：显示所有用户的所有进程。
   - `ps -ef`：显示所有用户的所有进程，与 `ps aux` 类似。
   - `ps aux | grep `：根据进程名搜索特定进程。

2. **top 命令：** `top` 命令用于实时监视系统的进程活动和资源使用情况。它提供了一个交互式界面，可以动态查看进程列表和资源利用情况。

3. **htop 命令：** `htop` 是 `top` 命令的改进版本，提供了更多的功能和交互性。它也用于实时监视进程和系统资源。

4. **kill 命令：** `kill` 命令用于终止正在运行的进程。要终止进程，您需要知道进程的 PID。默认情况下，`kill` 命令发送 TERM 信号，但您可以指定其他信号。

   常用选项和用法：

   - `kill `：发送 TERM 信号终止进程。
   - `kill -9 `：发送 KILL 信号终止进程。

5. **pgrep 命令：** `pgrep` 命令用于根据进程名查找进程的 PID。

   示例：

   ```
   pgrep <process_name>
   ```

6. **pkill 命令：** `pkill` 命令用于根据进程名终止进程。它比较方便，因为您不需要手动获取 PID。

   示例：

   ```
   pkill <process_name>
   ```

#### 优先级

 在 Linux 等一些类 Unix 操作系统中，进程的优先级范围通常是 -20 到 19。可以通过使用 `nice` 命令为进程分配一个优先级，负整数将优先级提高，正整数将优先级降低。例如，您可以使用 `-n` 选项来设置优先级： 

1. **nice 命令：**
   - `nice` 命令用于在运行新进程时设置进程的初始优先级。
   - 它可以让您在运行命令时调整新进程的优先级。
   - `nice` 命令后面跟着一个命令，该命令将以指定的优先级运行。
   - 优先级通过整数值来表示，负数表示较高的优先级，正数表示较低的优先级。
   - 一般用法：`nice -n priority command`
2. **renice 命令：**
   - `renice` 命令用于在进程运行时重新设置进程的优先级。
   - 它可以更改正在运行的进程的优先级。
   - `renice` 命令后面跟着一个或多个进程ID，然后指定一个新的优先级。
   - 优先级通过整数值来表示，负数表示较高的优先级，正数表示较低的优先级。
   - 一般用法：`renice -n  priority -p pid`

-------------------

#### 后台进程

1. **`jobs` 命令：**
   - `jobs` 命令用于显示当前终端会话中的后台作业（background jobs）列表。
   - 后台作业是在后台运行的进程，即不会占用当前终端并且可以继续进行其他命令操作。
   - `jobs` 命令会列出正在运行或停止的后台作业，并为每个作业分配一个作业编号（job number）。
2. **`bg` 命令：**
   - `bg` 命令用于将一个停止的后台作业转移到后台继续运行。
   - 可以使用作业编号或 `%` 后跟作业编号来指定要操作的作业。
   - 例如，`bg %1` 将作业编号为 1 的停止作业转移到后台继续运行。
3. **`fg` 命令：**
   - `fg` 命令用于将一个后台作业移到前台运行。
   - 与 `bg` 命令类似，您可以使用作业编号或 `%` 后跟作业编号来指定要操作的作业。
   - 例如，`fg %2` 将作业编号为 2 的后台作业切换到前台运行。

-------------------

--------------------------



## 多进程编程相关函数

可以通过创建一个子进程让其去完成一个特定的任务，还可以在子进程中去调用一个以及写好的程序，让其来完成特定的任务，父进程通过子进程的返回的status来判断是否完成任务，最后完成任务后回收进程。还可以根据任务的类型，创建守护进程。

### 进程创建

#### `fork`函数` unistd.h `

```
#include <unistd.h>

pid_t fork(void);
```

函数返回值：

- 在父进程中，`fork()` 返回子进程的 PID（正整数值）。
- 在子进程中，`fork()` 返回 0。

使用 `fork()` 函数，父进程可以创建一个完全独立的子进程，这在多进程编程中是很常见的模式。

 子进程拷贝了大部分父进程的信息，但子进程和父进程是独立的进程实体，它们的执行和资源是相互独立的。在子进程中的修改不会影响到父进程，反之亦然。 

1. **代码段：** 子进程将会获得与父进程相同的代码。这意味着子进程开始时会执行与父进程相同的代码。
2. **数据段：** 子进程将会拷贝父进程的数据段，包括全局变量和静态变量等。子进程的数据副本是独立的，对数据的修改不会影响父进程的数据。
3. **堆和栈：** 子进程会拥有与父进程相同的堆和栈，但这两个区域在物理内存中是独立的。子进程可以通过独立的堆和栈进行动态内存分配和函数调用。
4. **文件描述符：** 子进程会继承父进程的文件描述符，包括打开的文件、网络连接等。但这些描述符在子进程和父进程之间是独立的，关闭一个描述符不会影响另一个。
5. **进程状态：** 子进程会继承父进程的状态，例如打开的文件、信号处理函数等。但需要注意，某些状态可能需要进行适当的处理，以避免不希望的情况发生。

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t child_pid; // pid_t在wait.h中定义ide可能会标红!或者编译器会报错警告,可以使用__pid_t

    child_pid = fork();

    if (child_pid == 0) {
        // This is the child process
        printf("Child process: PID = %d\n", getpid());
    } else if (child_pid > 0) {
        // This is the parent process
        printf("Parent process: Child PID = %d\n", child_pid);
    } else {
        // Fork failed
        perror("Fork failed");
        return 1;
    }

    return 0;
}
```

父进程先结束则子进程会被init进程接管==>一直在运行变成后台进程(守护进程)

子进程先结束父进程没有回收,子进程变成**僵尸进程:** 当一个进程在执行完毕后，但其父进程还没有对其进行适当的资源清理和回收操作时，该进程会成为一个僵尸进程。僵尸进程在系统中存在，但已经不能再执行任何任务

僵尸进程最终会被init管理释放! 

--------------------------

### 进程返回值

进程可以向父进程返回一个int值，父进程根据这个值来判断子进程是否完成任务

#### `exit`函数 `stdlib.h`

`exit()` 函数用于正常终止程序，并在终止前执行一些清理操作，比如关闭文件、释放内存等。

在调用 `exit()` 时，C 运行时库会执行各种清理操作，退出状态可以在其他程序中检索，以确定程序的终止状态。

```c
#include <stdlib.h>

void exit(int status);
```

参数 `status` 是一个整数值，通常用来表示程序的退出状态。根据不同的约定，不同的状态码可能具有不同的含义。然而，以下是一些常用的约定：

- `EXIT_SUCCESS`：表示程序成功执行，通常是 0。
- `EXIT_FAILURE`：表示程序执行失败或出现错误，通常是非零值。
- 其他自定义的状态码：可以根据程序的需要定义其他状态码，以表示不同的错误类型或其他特定情况。

#### `_exit()` 函数 `unistd.h`

```c
#include <unistd.h>

void _exit(int status);
```

- `_exit()` 函数用于立即终止进程，不执行任何清理操作。它直接通过系统调用终止进程，不会刷新缓冲区、关闭文件等。
- `exit()` 函数通常比 `_exit()` 函数更适合正常终止程序，因为它提供了对资源的正确清理和关闭的机会。然而，在某些情况下，可能需要使用 `_exit()` 来避免不必要的清理操作。



--------------------------

### 执行新程序

#### `execl()` 函数 `unistd.h`

`execl()` 函数是一个在 Unix-like 操作系统中的系统调用函数，用于在当前进程中执行一个新的程序。它会取代当前进程的代码和数据，将其替换为新程序的代码和数据，从而实现程序的运行。

函数原型：

```
#include <unistd.h>

int execl(const char *path, const char *arg0, ... /*, (char *) NULL */);
```

参数说明：

- `path`：要执行的新程序的路径。这应该是一个可执行文件的路径。
- `arg0`：新程序的第一个参数，通常是程序的名称。
- 可变数量的参数：用于指定新程序的命令行参数。参数以空指针 `(char *) NULL` 结束。

返回值：

- 如果 `execl()` 函数执行成功，则不会返回，因为当前进程的代码和数据被替换为新程序的代码和数据。
- 如果 `execl()` 执行失败，它将返回 -1，并设置 `errno` 来指示错误的原因。

功能说明：

- `execl()` 函数会在当前进程的上下文中执行一个新的程序，取代当前进程的代码和数据。
- 新程序的路径由 `path` 参数指定，参数 `arg0` 指定新程序的名称。
- 可变数量的参数用于传递给新程序的命令行参数。
- 当 `execl()` 执行成功时，原始程序的状态和资源都会被新程序继承。
- `execl()` 不会创建新的进程，它直接在当前进程中执行新程序。因此，它通常在当前进程需要转变为不同程序的情况下使用。

```
#include <stdio.h>
#include <unistd.h>

int main() {
    printf("This is the original program.\n");

    execl("/bin/ls", "ls", "-l", NULL); 
    // 最后一个一定要是传入NULL参数,结束的标志

    // 如果 execl() 执行成功，下面的代码将不会执行
    perror("execl failed");
    return 1;
}
```



#### `execlp` 函数 `unistd.h`

`execlp()` 函数是在 Unix-like 操作系统中的一个系统调用函数，功能几乎与execl一致。与 `execl()` 不同，`execlp()` 允许您通过搜索系统的 `PATH` 环境变量来指定要执行的程序，而无需提供完整的路径。

函数原型：

```
#include <unistd.h>

int execlp(const char *file, const char *arg0, ... /*, (char *) NULL */);
```

参数说明：

- `file`：要执行的新程序的名称，不需要是完整的路径。`execlp()` 会通过搜索系统的 `PATH` 来找到可执行文件。
- `arg0`：新程序的第一个参数，通常是程序的名称。
- 可变数量的参数：用于指定新程序的命令行参数。参数以空指针 `(char *) NULL` 结束。

返回值：

- 如果 `execlp()` 函数执行成功，则不会返回，因为当前进程的代码和数据被替换为新程序的代码和数据。
- 如果 `execlp()` 执行失败，它将返回 -1，并设置 `errno` 来指示错误的原因。

功能说明：

- `execlp()` 函数会在当前进程的上下文中执行一个新的程序，取代当前进程的代码和数据。
- 新程序的名称由 `file` 参数指定，可以是在系统 `PATH` 中可找到的可执行文件。
- `arg0` 参数指定新程序的名称。
- 可变数量的参数用于传递给新程序的命令行参数。
- 当 `execlp()` 执行成功时，原始程序的状态和资源都会被新程序继承。
- `execlp()` 不会创建新的进程，它直接在当前进程中执行新程序。

#### `execv`函数 `unistd.h`

`execv()` 函数是在 Unix-like 操作系统中的一个系统调用函数，用于在当前进程中执行一个新的程序，与 `execl()` 和 `execlp()` 不同，`execv()` 使用一个参数数组来传递命令行参数。

函数原型：

```
#include <unistd.h>

int execv(const char *path, char *const argv[]);
```

参数说明：

- `path`：要执行的新程序的路径。这应该是一个可执行文件的路径。
- `argv`：一个字符串指针数组，用于传递新程序的命令行参数。数组的最后一个元素必须是空指针 `(char *) NULL`。

返回值：

- 如果 `execv()` 函数执行成功，则不会返回，因为当前进程的代码和数据被替换为新程序的代码和数据。
- 如果 `execv()` 执行失败，它将返回 -1，并设置 `errno` 来指示错误的原因。

功能和execl一致

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    printf("This is the original program.\n");

    char *const args[] = {"ls", "-l", NULL};
    execv("/bin/ls", args);

    // 如果 execv() 执行成功，下面的代码将不会执行
    perror("ls failed");
    return 1;
}
```

#### `execvp` 函数 `unistd.h`

`execvp()` 函数是在 Unix-like 操作系统中的一个系统调用函数，用于在当前进程中执行一个新的程序，类似于 `execlp()`，但是使用一个参数数组来传递命令行参数。

函数原型：

```
 #include <unistd.h>

int execvp(const char *file, char *const argv[]);
```

参数说明：

- `file`：要执行的新程序的名称，不需要是完整的路径。`execvp()` 会通过搜索系统的 `PATH` 来找到可执行文件。
- `argv`：一个字符串指针数组，用于传递新程序的命令行参数。数组的最后一个元素必须是空指针 `(char *) NULL`。

返回值：

- 如果 `execvp()` 函数执行成功，则不会返回，因为当前进程的代码和数据被替换为新程序的代码和数据。
- 如果 `execvp()` 执行失败，它将返回 -1，并设置 `errno` 来指示错误的原因。

-------------------------

### 进程回收 

`wait()` 函数是一个在 Unix-like 操作系统中的系统调用函数，用于等待一个子进程的终止，并获取子进程的退出状态。它允许父进程阻塞，直到指定的子进程终止为止。

函数原型：

```
#include <sys/wait.h>

pid_t wait(int *status);
```

参数说明：

- `status`：一个指向整数的指针，用于存储子进程的退出状态。如果不需要获取子进程的退出状态，可以传递 NULL。

返回值：

- 如果成功等待到子进程的终止，`wait()` 函数会返回终止的子进程的进程ID。
- 如果没有子进程可等待，且没有设置非阻塞等待的选项，则 `wait()` 函数将阻塞父进程，直到有一个子进程终止。

功能说明：

- `wait()` 函数用于等待一个子进程的终止，并获取子进程的退出状态。
- 如果成功等待到子进程的终止，它会返回终止的子进程的进程ID，如果 `status` 参数不是 NULL，它也会存储子进程的退出状态。
- 如果没有子进程可等待，且没有设置非阻塞等待的选项，则父进程将阻塞，直到有一个子进程终止。
- 如果 `status` 参数为 NULL，父进程将无法获取子进程的退出状态，但仍然可以使用 `waitpid()` 函数等待子进程的终止。

处理进程返回值的宏,返回值中高八位通常是返回值的数据,这个数据由程序员去定义意义

1. `WIFEXITED(status)`: 用于判断子进程是否正常终止（通过调用 `_exit()` 或 `exit()` 函数）。
2. `WEXITSTATUS(status)`: 用于获取子进程的退出状态，仅在 `WIFEXITED(status)` 为真时使用。
3. `WIFSIGNALED(status)`: 用于判断子进程是否因为信号而终止。
4. `WTERMSIG(status)`: 用于获取导致子进程终止的信号编号，仅在 `WIFSIGNALED(status)` 为真时使用。
5. `WCOREDUMP(status)`: 用于判断子进程是否产生了 core dump 文件（在某些情况下，进程终止时会生成一个 core dump 文件，以便分析问题）。

```c
if (WIFEXITED(status))
{
	printf("子进程正常结束\n");
}
```

#### `waitpid`函数 ` sys/wait.h `

与 `wait()` 不同，`waitpid()` 允许您指定要等待的子进程的进程ID，从而更加灵活地管理多个子进程。

函数原型：

```
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *status, int options);
```

参数说明：

- pid：要等待的子进程的进程ID。
  - **如果 `pid` 大于 0，表示等待具有该进程ID的子进程。**
  - 如果 `pid` 等于 0，表示等待与调用进程位于同一进程组的任意子进程。
  - **如果 `pid` 等于 -1，表示等待任意子进程。**
  - 如果 `pid` 小于 -1，表示等待进程组ID等于 `pid` 绝对值的任意子进程。
- `status`：一个指向整数的指针，用于存储子进程的退出状态。如果不需要获取子进程的退出状态，可以传递 NULL。
- `options`：控制等待的选项，通常为 0阻塞等待。
  - `WNOHANG`：非阻塞等待。如果没有满足条件的子进程终止
  - `waitpid()` 将立即返回，而不会阻塞父进程。如果有满足条件的子进程终止，返回子进程的进程ID。
  - `WUNTRACED`：等待被暂停的子进程。这个选项用于等待子进程进入暂停状态，通常是因为接收到 `SIGSTOP` 或 `SIGTSTP` 信号。返回满足条件的子进程的进程ID。
  - `WCONTINUED`：等待被继续的子进程。这个选项用于等待子进程从暂停状态恢复继续执行，通常是因为接收到 `SIGCONT` 信号。返回满足条件的子进程的进程ID。
  - `WSTOPPED`：等待任何暂停的子进程。等价于 `WUNTRACED | WCONTINUED`，用于等待被暂停或被继续的子进程。返回满足条件的子进程的进程ID。
  - `WEXITED`：等待已经终止的子进程。与这个选项一起使用时，`waitpid()` 只会等待已经终止的子进程，而不会等待正在运行的或被暂停的子进程。

返回值：

- 如果成功等待到指定的子进程终止，`waitpid()` 函数会返回终止的子进程的进程ID。
- 如果没有满足条件的子进程，且设置了非阻塞等待的选项，`waitpid()` 将返回 0。
- 如果调用出错，`waitpid()` 将返回 -1，并设置 `errno` 来指示错误的原因。

-------------------------

### 守护进程的创建

1. **创建子进程并退出父进程**：首先，创建一个子进程，然后使父进程退出。这确保子进程不会成为会话的首领（session leader）。
2. **在子进程中创建新会话**：子进程调用 `setsid()` 函数来创建一个新的会话。这将使子进程成为新会话的首领，并且与原始终端完全脱离关联。
3. **更改当前工作目录**：为了避免挂载点问题，将当前工作目录更改为根目录（或其它安全目录）。
4. **关闭文件描述符**：关闭标准输入、标准输出和标准错误输出，以避免守护进程产生不必要的输出。
5. **处理信号**：注册信号处理函数来处理守护进程可能遇到的信号，如 `SIGHUP`、`SIGTERM` 等。这些信号可以用来重新加载配置文件、优雅地终止进程等。
6. **执行守护进程任务**：在子进程中执行守护进程的主要任务，如提供服务、监控资源、处理请求等。
7. **关闭文件描述符和资源**：确保在守护进程结束时关闭所有打开的文件描述符，并释放申请的资源，以避免资源泄漏。
8. **退出守护进程**：守护进程完成任务后，通过调用 `_exit()` 函数来正常终止。



#### `setsid`函数 `unistd.h`

```c
#include <unistd.h>

pid_t setsid(void);
```

- 如果调用成功，`setsid()` 在子进程中，它将返回新的会话首领（新的进程组首领）的进程ID。
- 如果调用失败，`setsid()` 函数返回 -1，并设置 `errno` 来指示错误的原因。

####  `umask` 函数  `sys/stat.h`

文件掩码是一个权限掩码，通过与文件的默认权限进行按位操作后得到真实权限，用于确定新创建文件的默认权限。

默认的掩码为`022`

 如果文件掩码设置为 `022`，那么新创建的文件将具有默认权限 `0666 & ~022 = 0644`，其中 `0666` 表示默认权限，`022` 表示要屏蔽的权限位。 

函数原型：

```c
#include <sys/stat.h>
mode_t umask(mode_t mask);
```

参数：

- `mask`：新的文件掩码，使用 `mode_t` 类型表示。传递给 `umask()` 函数的掩码值将被保存，同时返回之前的文件掩码值。

返回值：

- 成功返回之前的文件掩码值。
- 失败返回-1

#### `getdtablesize`函数`unistd.h`

在早期的 Unix 系统中，`getdtablesize()` 函数用于获取进程的文件描述符表的大小（即打开文件描述符的数量上限）。然而，自从 POSIX 标准化之后，`getdtablesize()` 函数已被废弃，并且在现代的操作系统中不再推荐使用。

取而代之的是使用 `sysconf(_SC_OPEN_MAX)` 来获取文件描述符的最大数量。`sysconf()` 函数用于查询系统限制或选项的值。参数 `_SC_OPEN_MAX` 表示文件描述符的最大数量。这是一种更加通用和可移植的方式来获取文件描述符的数量上限。

```c
long max_fds = sysconf(_SC_OPEN_MAX); 
if (max_fds == -1) {
       perror("sysconf failed");
       return 1;
}
```



```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <unistd.h>

void create_daemon() {
    // Fork and exit the parent process
    pid_t pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        exit(1);
    }

    if (pid > 0) {
        exit(0);  // Parent process exits
    }

    // Create a new session
    if (setsid() < 0) {
        perror("setsid failed");
        exit(1);
    }

    //  Change working directory 
    if (chdir("/") < 0) { 
        // 或者设置为 /temp 
        // 守护进程的工作目录不能被卸载
        perror("chdir failed");
        exit(1);
    }

    //  Close file descriptors
    // 关闭流: 0,1,2
    for(int i=0;getdtablesize();i++){
        close(i); //关闭所有拷贝得到的文件
    }

    //Set a new file mode mask
    umask(0);  // Reset the file mode mask to 0

    // Daemon tasks 
    while (1) {
        // Your daemon tasks go here
        sleep(1);
    }
}

int main() {
    create_daemon();
    return 0;
}
```

--------------------------

--------------------------

## 进程间的通信

 早期的Unix系统引入了一些基本的进程间通信方式，这些方式仍然在一定程度上影响了后来的IPC机制。 

- 无名管道 pipe
- 有名管道fifo
- 信号 signal

System V IPC（Inter-Process Communication）是一组在Unix和类Unix系统中用于进程间通信的机制，由AT&T的System V操作系统引入。System V IPC提供了多种进程间通信方式，包括消息队列、共享内存和信号量。 

- 共享内存
- 消息队列
- 信号灯集

还可以使用 套接字 进行进程间通信

### 无名管道 `unistd.h`

- **单向通信：** 无名管道是单向的，即数据只能在一个方向上流动，一端用于写入数据，另一端用于读取数据。
- **半双工：** 无名管道是半双工的，意味着数据只能在一个方向上传输，不支持双向通信。
- **局限性：** 无名管道只能在有亲缘关系的进程之间使用，即由同一父进程派生出来的进程。
- **通过文件描述符通信**：会返回一个文件描述符

#### `pipe` 函数

`pipe` 函数的原型如下：

```
#include <unistd.h>

int pipe(int pipefd[2]);
```

参数 `pipefd` 是一个整型数组，大小为2，用于返回两个文件描述符：`pipefd[0]` 用于读取数据，`pipefd[1]` 用于写入数据。

- `pipefd[0]`：文件描述符，用于从管道中读取数据。
- `pipefd[1]`：文件描述符，用于向管道中写入数据。

返回值：

- 如果函数调用成功，返回值为0。
- 如果出现错误，返回值为-1，并且设置全局变量 `errno` 来指示错误的类型。

以下是使用 `pipe` 函数创建无名管道的基本步骤：

1. 调用 `pipe` 函数，传递一个长度为2的整型数组作为参数，以获取读取和写入两个文件描述符。
2. 调用 `fork` 函数创建子进程。
3. 在父进程中，关闭不需要的文件描述符。通常情况下，父进程会关闭写入端（`pipefd[1]`）。
4. 在子进程中，关闭不需要的文件描述符。通常情况下，子进程会关闭读取端（`pipefd[0]`）。
5. 在父进程中，通过写入文件描述符 `pipefd[1]` 将数据传递给子进程。
6. 在子进程中，通过读取文件描述符 `pipefd[0]` 读取从父进程传递的数据。
7. 进程结束需要即时关闭自己所使用的文件描述符

需要注意的是，无名管道是单向的、半双工的通信方式，通常用于有亲缘关系的进程之间。如果需要实现双向通信，需要创建两个无名管道。

实际上可以实现双向通信==>但是会出现一个问题,如果如果同一个进程读完立马写将会读到自己写入的数据,然后造成另外一端阻塞,所以一般就只写或只读

没有及时关闭对应写端,读端会造成阻塞问题

- 写端存在==>读端读不到数据阻塞
- 写端不存在==>读端读不到数据不阻塞

写端的阻塞只会取决于管道大小==>满了阻塞

**另外无名管道的读取好像不是原子操作**,尽可能的只用在两个进程之间~





--------------------------

### 有名管道:`sys/stat.h`

用文件名称来标识管道,其他进程可以通过打开这个文件,向这个文件读写数据,数据是放在内存中不是在文件内

#### `mkfifo`函数

`mkfifo` 函数用于在文件系统中创建命名管道（Named Pipe），其参数和返回值如下：

```
#include <sys/stat.h>

int mkfifo(const char *pathname, mode_t mode);
```

- `pathname`：要创建的命名管道的路径名。
- `mode`：指定创建后的管道的权限模式。通常使用八进制表示，例如 `0666`。

返回值：

- 如果 `mkfifo` 函数调用成功，返回值为 0。
- 如果 `mkfifo` 函数调用失败，返回值为 -1，并且可以通过查看全局变量 `errno` 来获取具体的错误信息。可以使用 `perror` 函数将错误信息输出到标准错误流





--------------------------

### 信号机制

信号机制是对中断的软件层面的模拟

信号是在 Unix-like 操作系统中用于进程间通信和处理异步事件的一种机制。信号是一种软件中断，可以被一个进程发送给另一个进程或者同一个进程的不同线程，用来通知某种事件的发生，例如错误、警告、中断等。每个信号都有一个唯一的编号，通常用整数表示。 

进程对信号的响应方式

- 缺省方式:采用默认的处理方式
- 忽略信号
- 捕捉信号

常用信号

- **SIGINT（中断信号）：** 通常由用户在终端按下 Ctrl+C 触发，用于中止正在运行的程序。
- **SIGTERM（终止信号）：** 用于请求进程优雅地终止，以便进程有机会进行清理操作。
- **SIGKILL（强制终止信号）：** 用于强制终止进程，不能被忽略。
- **SIGHUP（挂起信号）：** 通常用于通知进程重新加载配置文件或重新初始化。
- **SIGSTOP（停止信号）：** 用于暂停进程的执行，不能被忽略。
- **SIGCONT（继续信号）：** 用于恢复因收到 SIGSTOP 或 SIGTSTP 而暂停的进程。
- **SIGCHLD（子进程状态改变信号）：** 通知父进程子进程的状态改变。
- **SIGPIPE（管道破裂信号）：** 通知进程向已经关闭的管道写入数据。
- **SIGALRM（定时器信号）：** 通常用于定时器操作，可以通过设置信号处理函数来处理定时器事件。
- **SIGUSR1 和 SIGUSR2（用户自定义信号）：** 供应用程序自定义使用的信号。
- **SIGSEGV（段错误信号）：** 通常在访问无效内存地址时触发。
- **SIGBUS（总线错误信号）：** 通常在出现内存对齐问题时触发。
- **SIGFPE（浮点异常信号）：** 通常在执行浮点运算时发生错误时触发。
- **SIGQUIT（退出信号）：** 通常由用户在终端按下 Ctrl+\ 触发，用于退出程序，并生成核心转储文件。
- **SIGTERM（终止信号）：** 通常用于请求进程终止，但可以被捕获和处理。

相关信号命令

```
kill [options] <pid> [...] 
```

其中，`pid` 是目标进程的进程ID，可以同时指定多个进程ID。`options` 是一些选项，用于指定要发送的信号。以下是一些常用的 `kill` 命令选项和信号：

常用选项：

- `-s `：指定要发送的信号。例如：`-s SIGTERM`。

常用信号：

- `SIGTERM`：默认终止信号，请求进程优雅地终止。
- `SIGINT`：中断信号，通常由用户在终端按下 Ctrl+C 触发。
- `SIGHUP`：挂起信号，用于通知进程重新加载配置文件或重新初始化。
- `SIGKILL`：强制终止信号，无法被忽略。
- `SIGSTOP`：停止信号，用于暂停进程的执行，无法被忽略。

例子:

1. 发送 SIGTERM 终止信号给进程号为 12345 的进程：

   ```
   kill -s SIGTERM 12345
   ```

2. 使用缩写形式发送中断信号给进程号为 6789 的进程：

   ```
   kill -2 6789
   ```

3. 使用 `killall` 命令发送信号给所有同名进程：

   ```
   killall -s SIGTERM myprocess
   ```

`killall` 命令是在 Unix-like 操作系统中用于向指定名称的进程发送信号的命令。与 `kill` 命令不同，`killall` 命令不需要指定进程的PID，而是根据进程的名称来进行操作。使用 `killall` 命令，你可以一次性终止或操作多个同名进程。

`killall` 命令的基本语法如下：

```
killall [options] <process_name> [...]
```

其中，`process_name` 是目标进程的名称，可以同时指定多个进程名称。`options` 是一些选项，用于指定要发送的信号等。

```
killall -u username # 杀死某个用户的所有进程
```

--------------------------

--------------------------



#### `kill`函数: `signal.h`

`kill` 函数是在 Unix-like 操作系统中用于向进程发送信号的系统调用函数。通过调用 `kill` 函数，一个进程可以向另一个进程或自身发送不同的信号，影响进程的行为。`kill` 函数的原型如下：

```
#include <signal.h>

int kill(pid_t pid, int sig);
```

 `pid` 是目标进程的进程ID，`sig` 是要发送的信号的编号。 

- 如果成功发送信号，`kill` 函数返回 `0`。
- 如果出现错误，`kill` 函数返回 `-1`，并设置全局变量 `errno` 来指示具体的错误类型。



--------------------------

#### `raise`函数: `signal.h`

`raise` 函数用于向当前进程发送指定的信号。可以在程序中调用来触发信号。以下是 `raise` 函数的详细信息：

**函数原型：**

```
#include <signal.h>

int raise(int sig);
```

**参数：**

- `sig`：要发送的信号的编号，可以是标准信号如 `SIGINT`、`SIGTERM` 等，也可以是用户定义的信号。

**返回值：**

- 如果成功发送信号，`raise` 函数返回 `0`。
- 如果出现错误，`raise` 函数返回 `-1`，并设置全局变量 `errno` 来指示具体的错误类型。

**功能介绍：**

`raise` 函数的主要功能是触发指定的信号。它允许你在程序中显式地发送信号，以便实现自定义的信号处理行为。当你调用 `raise` 函数并传递一个信号编号时，操作系统会将该信号发送给当前进程。信号的处理方式取决于进程中为该信号设置的信号处理函数，或者使用默认的信号处理方式。

例如，你可以使用 `raise(SIGTERM)` 来请求当前进程自愿地终止，这类似于在终端按下 Ctrl+C。或者，你可以使用 `raise(SIGINT)` 来触发中断信号，也就是同样的终端中断操作。需要注意的是，信号的处理方式和具体影响会因信号类型和进程状态而异。

--------------------------

#### `signal` 函数:`signal.h`

`signal` 函数是用于注册信号处理函数的库函数。信号处理函数是在收到指定信号时执行的函数，允许你对信号进行自定义处理。`signal` 函数的原型如下：

```
#include <signal.h>

void (*signal(int signum, void (*handler)(int)))(int);
```

**参数：**

- `signum`：要注册信号处理函数的信号编号，可以是标准信号如 `SIGINT`、`SIGTERM` 等，也可以是用户定义的信号。
- `handler`：要注册的信号处理函数的函数指针。该函数应该接受一个整数参数，表示信号的编号。

**返回值：**

- `signal` 函数的返回值是之前注册的信号处理函数的函数指针。如果之前未注册过信号处理函数，则返回 `SIG_DFL`（默认信号处理）。

**功能介绍：**

`signal` 函数用于注册信号处理函数，以便在接收到指定的信号时执行自定义的处理代码。当进程接收到指定信号时，会调用注册的信号处理函数，并传递信号的编号作为参数。

需要注意的是，`signal` 函数在新的 POSIX 标准中已经被废弃，因为其在多线程环境下不安全。推荐使用 `sigaction` 函数来代替，因为 `sigaction` 提供了更强大和可靠的信号处理机制。

--------------------------

#### `alarm`函数:`unistd.h`

`alarm` 函数用于设置定时器，以在指定的时间后向进程发送 `SIGALRM` 信号。它是一个库函数，常用于实现定时操作，例如在一定时间后执行某个任务。以下是 `alarm` 函数的详细信息：

**函数原型：**

```
#include <unistd.h>

unsigned int alarm(unsigned int seconds);
```

**参数：**

- `seconds`：定时器的时间，以秒为单位。指定时间过后，系统将向进程发送 `SIGALRM` 信号。

**返回值：**

- 调用 `alarm` 函数会返回前一个设置的定时器剩余时间。如果之前没有设置定时器，或者之前定时器已经到期，返回值为 `0`。

**功能介绍：**

`alarm` 函数的主要功能是设置定时器，以在指定的时间后触发 `SIGALRM` 信号。当定时器到期时，操作系统会将 `SIGALRM` 信号发送给当前进程，从而触发相应的信号处理函数或默认的信号处理行为。

示例用法：

```
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void alarm_handler(int sig) {
    printf("Received SIGALRM signal\n");
}

int main() {
    // 设置定时器，在5秒后触发SIGALRM信号
    unsigned int remaining = alarm(5);

    // 注册信号处理函数
    signal(SIGALRM, alarm_handler);

    printf("Waiting for alarm...\n");
    sleep(10);  // 让进程休眠，等待定时器触发

    // 清除定时器
    unsigned int canceled = alarm(0);
    printf("Remaining time: %u seconds\n", remaining);
    printf("Canceled time: %u seconds\n", canceled);

    return 0;
}
```

使用了 `alarm` 函数来设置一个定时器，在5秒后触发 `SIGALRM` 信号。然后注册了一个信号处理函数 `alarm_handler` 来处理这个信号。程序休眠10秒，以等待定时器触发。最后，我们使用 `alarm(0)` 清除了定时器。运行该程序时，你会看到在5秒后输出 "Received SIGALRM signal"。

--------------------------

#### `pause` 函数:`unistd.h`

`pause` 函数是一个库函数，用于使当前进程进入休眠状态，直到接收到一个信号。当进程调用 `pause` 函数后，它会暂停执行，直到收到一个信号，然后才会继续执行。以下是 `pause` 函数的详细信息：

**函数原型：**

```
#include <unistd.h>

int pause(void);
```

**返回值：**

- `pause` 函数不会返回 `-1`，而是在收到一个信号时被中断，然后再继续执行。因此，它没有实际的返回值。

**功能介绍：**

`pause` 函数的主要功能是使当前进程进入休眠状态，直到接收到一个信号。当调用 `pause` 函数后，进程会进入一个无限循环等待状态，直到收到一个信号。一旦收到信号，进程会被信号处理函数中断，执行信号处理函数的代码，然后继续执行 `pause` 函数之后的代码。

示例用法：

```c
#include <stdio.h>
#include <signal.h>

void signal_handler(int sig) {
    printf("Received signal: %d\n", sig);
}

int main() {
    // 注册信号处理函数
    signal(SIGUSR1, signal_handler);

    printf("Waiting for signal...\n");
    pause();  // 进程进入休眠状态，等待信号触发

    printf("Resumed after signal\n");

    return 0;
}
```

在上述示例中，我们使用了 `pause` 函数使进程进入休眠状态，等待 `SIGUSR1` 信号的触发。当我们在另一个终端窗口中向进程发送 `SIGUSR1` 信号时，进程会被中断并执行信号处理函数，然后继续执行 `pause` 函数之后的代码。





--------------------------

### System V IPC

IPC对象有唯一ID,创建后需要显示删除,IPC对象有一个关联的Key

#### `ftok`函数:` sys/ipc.h `

`ftok` 函数是用于生成 System V IPC（Inter-Process Communication）中关联键（key）的函数。关联键用于标识和定位 IPC 对象，如信号量、共享内存和消息队列。

函数原型如下：

```
key_t ftok(const char *pathname, int proj_id);
```

- `pathname`：一个字符串，通常是一个现有文件的路径。`ftok` 使用这个路径名来生成关联键。
- `proj_id`：一个整数，通常是一个非负的用户指定的标识符。可以用来在同一个路径下生成不同的关联键。

函数返回值是生成的关联键（key）。**如果发生错误，返回值为 -1，并设置全局变量 `errno` 表示具体的错误原因。**

`ftok` 函数的功能是将给定的文件路径名和用户指定的标识符组合，生成一个唯一的关联键。生成的关联键可以被用来创建和定位 System V IPC 对象。需要注意的是，不同的文件路径和不同的标识符会生成不同的关联键。

通常情况下，`ftok` 函数用于在不同进程或应用程序之间生成相对唯一的关联键，以确保 IPC 对象能够正确地被标识和访问。在使用时，应确保 `pathname` 参数是一个现有的文件路径，且 `proj_id` 不要过于频繁地变化，以免生成相同的关联键。



--------------------------

#### 共享内存`sys/shm.h`

需要同步和互斥机制配合使用使用

- 创建内存==>得到ID
- 内存映射==>
- 读写内存
- 任务结束撤销映射
- 删除共享内存

ipcs命令

命令中的 `ipcs` 是用于显示 System V IPC（Inter-Process Communication）对象状态的命令，可以查看系统中当前存在的共享内存、信号量和消息队列等 IPC 对象的信息。

正确的命令是 `ipcs -a`，而不是 `ipcs -;`。下面是正确命令的用法和一些常用选项：

- `ipcs -a`：显示所有的 IPC 对象信息，包括共享内存、信号量和消息队列。
- `ipcs -m`：只显示共享内存信息。
- `ipcs -s`：只显示信号量信息。
- `ipcs -q`：只显示消息队列信息。
- `ipcs -l `： 展示出 IPC 相关的系统级别的参数配置，包括消息队列、信号量和共享内存的一些限制和属性 

可以用 `cat /proc/sys/kernel/shmmax` 命令用于查看 Linux 内核中共享内存的最大大小限制。在 Linux 系统中，共享内存的大小限制可以通过修改内核参数来调整，这个命令可以用来查看当前的设置。 



--------------------------

##### `shmget` 函数

`shmget` 函数用于创建或获取共享内存段，它是 System V IPC（Inter-Process Communication）中的一部分。共享内存允许多个进程在同一片内存上进行读写操作，从而实现高效的进程间通信和数据共享。

函数原型如下：

```
int shmget(key_t key, size_t size, int shmflg);
```

- `key`：关联键，用于标识和定位共享内存段。
- `size`：要创建的共享内存段的大小（字节数）。
- `shmflg`：标志位，用于控制共享内存的创建方式和权限。

函数返回值是共享内存段的标识符（ID）。如果出现错误，返回值为 -1，并设置全局变量 `errno` 表示具体的错误原因。

以下是一些常见的 `shmflg` 标志位：

- `IPC_CREAT`：如果共享内存不存在，则创建它。
- `IPC_EXCL`：与 `IPC_CREAT` 一起使用，如果共享内存已存在，则返回错误。
- `IPC_PRIVATE`：用于创建私有的匿名共享内存段。
- 权限标志（如 `0666`）：指定共享内存的权限。

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>

int main() {
    key_t key = ftok("/tmp/shm_key", 1);  // 创建关联键
    size_t size = 1024;  // 共享内存大小
    int shmflg = IPC_CREAT | 0666;  // 创建标志和权限

    int shmid = shmget(key, size, shmflg);

    if (shmid == -1) {
        perror("shmget");
        exit(EXIT_FAILURE);
    }

    printf("Shared memory ID: %d\n", shmid);

    return 0;
}
```

--------------------------

##### `shmat `函数

`shmat` 函数用于将共享内存段映射到当前进程的地址空间，以便可以在进程中访问共享内存的内容。它是 System V IPC（Inter-Process Communication）中的一部分。

函数原型如下：

```
void *shmat(int shmid, const void *shmaddr, int shmflg);
```

- `shmid`：共享内存段的标识符（ID），由 `shmget` 函数返回。
- `shmaddr`：映射的地址。通常设置为 `NULL`，表示让系统选择一个合适的地址。如果指定了一个非空的地址，系统会尝试将共享内存映射到这个地址。
- `shmflg`：标志位，用于控制映射方式和权限。

函数返回值是指向映射后共享内存的指针。如果出现错误，返回值为 `(void *)-1`，并设置全局变量 `errno` 表示具体的错误原因。

以下是一些常见的 `shmflg` 标志位：

- `SHM_RDONLY`：只读方式映射共享内存。
- 0：通常表示普通映射方式。

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/shm.h>

int main() {
    int shmid = 12345;  // 假设共享内存的标识符为 12345
    void *shmaddr;

    shmaddr = shmat(shmid, NULL, 0);

    if (shmaddr == (void *)-1) {
        perror("shmat");
        exit(EXIT_FAILURE);
    }

    // 现在可以通过 shmaddr 访问共享内存的内容
    // ...

    // 解除共享内存的映射
    shmdt(shmaddr);

    return 0;
}
```

在这个示例中，我们使用 `shmat` 函数将共享内存映射到当前进程的地址空间，然后可以通过得到的 `shmaddr` 指针来访问共享内存的内容。完成后，我们使用 `shmdt` 函数解除映射。需要注意，映射共享内存后，我们可以像操作普通内存一样操作它，但是需要注意同步和互斥问题，以免造成数据一致性问题。

--------------------------

##### `shmdt` 函数

`shmdt` 函数用于解除共享内存段与当前进程地址空间的映射关系，即将共享内存从当前进程中分离，使进程不能再访问共享内存的内容。它是 System V IPC（Inter-Process Communication）中的一部分。

函数原型如下：

```
int shmdt(const void *shmaddr);
```

- `shmaddr`：要解除映射的共享内存地址。

函数返回值是 0 表示成功，-1 表示失败，并设置全局变量 `errno` 表示具体的错误原因。

示例用法：

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/shm.h>

int main() {
    int shmid = 12345;  // 假设共享内存的标识符为 12345
    void *shmaddr;

    shmaddr = shmat(shmid, NULL, 0);

    if (shmaddr == (void *)-1) {
        perror("shmat");
        exit(EXIT_FAILURE);
    }

    // 现在可以通过 shmaddr 访问共享内存的内容
    // ...

    // 解除共享内存的映射
    if (shmdt(shmaddr) == -1) {
        perror("shmdt");
        exit(EXIT_FAILURE);
    }

    return 0;
}
```

在这个示例中，我们首先使用 `shmat` 函数将共享内存映射到当前进程的地址空间，然后可以通过得到的 `shmaddr` 指针访问共享内存的内容。完成后，使用 `shmdt` 函数解除映射，这样当前进程就不能再访问共享内存的内容了。在实际使用时，务必确保解除映射，以免造成资源泄漏。

--------------------------

##### `shmctl` 函数

`shmctl` 函数用于对共享内存段进行控制操作，它是 System V IPC（Inter-Process Communication）中的一部分。通过这个函数，可以执行一系列操作，如获取共享内存信息、修改权限、删除共享内存等。

函数原型如下：

```
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
```

- `shmid`：共享内存段的标识符（ID），由 `shmget` 函数返回。
- `cmd`：控制命令，用于指定要执行的操作。常见的命令有 `IPC_STAT`、`IPC_SET`、`IPC_RMID` 等。
- `buf`：一个指向 `struct shmid_ds` 结构的指针，用于传递或接收共享内存信息。

函数返回值是操作的执行结果。如果出现错误，返回值为 -1，并设置全局变量 `errno` 表示具体的错误原因。

以下是一些常见的 `cmd` 控制命令：

- `IPC_STAT`：获取共享内存信息并将其填充到传入的 `buf` 结构中。
- `IPC_SET`：修改共享内存的权限和一些其他属性。
- `IPC_RMID`：删除共享内存段。

示例用法：

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/shm.h>

int main() {
    int shmid = 12345;  // 假设共享内存的标识符为 12345
    struct shmid_ds shm_info;

    // 获取共享内存信息
    if (shmctl(shmid, IPC_STAT, &shm_info) == -1) {
        perror("shmctl");
        exit(EXIT_FAILURE);
    }

    printf("Size of shared memory: %lu bytes\n", shm_info.shm_segsz);
    printf("Last attach time: %ld\n", shm_info.shm_atime);

    return 0;
}
```

在这个示例中，我们使用 `shmctl` 函数执行了 `IPC_STAT` 控制命令，获取了共享内存的信息并将其填充到 `shm_info` 结构中。然后，我们可以通过结构中的成员来获取共享内存的大小和最后一次附加的时间等信息。



--------------------------

#### 消息队列 ` sys/msg.h `

消息队列是一种进程间通信（IPC）机制，用于在不同进程之间传递消息。它可以让多个进程通过往队列中发送和接收消息来实现数据交换和通信。消息队列通常用于进程之间的异步通信，进程可以独立地发送和接收消息，而不需要直接进行读写操作。

在 Linux 系统中，消息队列是 System V IPC（Inter-Process Communication）的一部分。使用消息队列，进程可以在消息队列中放置消息，其他进程可以从队列中读取这些消息。消息队列具有以下特点：

- 消息队列可以实现多对多的通信，即多个进程可以同时发送和接收消息。
- 每个消息都有一个类型标识，接收进程可以选择接收特定类型的消息。
- 消息队列支持阻塞和非阻塞的消息发送和接收操作。

相关函数操作

- `msgget`：创建或获取消息队列。
- `msgsnd`：将消息发送到消息队列。
- `msgrcv`：从消息队列接收消息。
- `msgctl`：控制消息队列的操作，如删除消息队列、获取信息等。

--------------------------

##### `msgget`函数

创建或获取消息队列。

`int msgget(key_t key, int msgflg);`

- 函数原型：`int msgget(key_t key, int msgflg);`
- 返回值：成功时返回消息队列的标识符（非负整数），失败时返回 -1。
- 参数：
  - `key`：消息队列的关联键，用于唯一标识消息队列。
  - `msgflg`：标志和权限，用于指定创建消息队列的选项和权限。一般是:`IPC_CREAT | 0666;`
    消息队列的标志可以由以下常量通过按位或（`|`）操作组合而成：
    - `IPC_CREAT`：如果消息队列不存在则创建它。
    - `IPC_EXCL`：与 `IPC_CREAT` 一同使用时，如果消息队列已存在，则返回错误。
    - `IPC_NOWAIT`：如果操作无法立即完成，则不等待



--------------------------

##### `msgsnd`函数 

将消息发送到消息队列。

`int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);`

- 函数原型：`int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);`

- 返回值：成功时返回0，失败时返回-1。

- 参数：

  - `msqid`：消息队列的标识符。

  - `msgp`：指向待发送消息的指针，消息的类型在结构体的 `mtype` 字段中，消息的数据在后续的字段中。

  - `msgsz`：消息的大小，不包括 `mtype` 字段的大小。
    消息格式:

    ```
    struct message {
        long mtype;              // 消息类型==>必须包含这个开头,必须是long
        char mtext[MAX_TEXT];    // 消息内容==>自定义,任意消息
    };
    ```

    

  - `msgflg`：发送消息的选项标志。

    - `IPC_NOWAIT`：如果消息队列已满，则立即返回错误，而不阻塞。
    - `MSG_NOERROR`：如果消息内容大于队列的最大消息大小，则截断消息。

--------------------------

##### `msgrcv`函数

从消息队列接收消息。

`ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);`

- 函数原型：`ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);`
- 返回值：成功时返回接收到的消息的数据部分的大小，失败时返回-1。
- 参数：
  - `msqid`：消息队列的标识符。
  - `msgp`：指向接收消息的缓冲区的指针。
  - `msgsz`：缓冲区的大小，必须大于等于消息数据的大小。
  - `msgtyp`：指定接收消息的类型标识，为0表示接收队列中的第一条消息。
  - `msgflg`：接收消息的选项标志。

--------------------------

##### `msgctl`函数

控制消息队列的操作，如删除消息队列、获取信息等。

`int msgctl(int msqid, int cmd, struct msqid_ds *buf);`

- 函数原型：`int msgctl(int msqid, int cmd, struct msqid_ds *buf);`
- 返回值：成功时返回0，失败时返回-1。
- 参数：
  - `msqid`：消息队列的标识符。
  - `cmd`：控制命令，用于指定要执行的操作，如获取信息、删除队列等。
    `cmd` 可以取以下值之一：
    - `IPC_STAT`：获取消息队列的状态信息，将结果存储在 `buf` 中。
    - `IPC_SET`：设置消息队列的状态信息，根据 `buf` 中的值进行设置。
    - `IPC_RMID`：删除消息队列。
  - `buf`：指向 `struct msqid_ds` 结构的指针，用于传递或接收消息队列信息。

这些函数可以用于创建、发送、接收和控制 System V IPC 消息队列。在使用它们时，请确保正确处理错误情况并根据具体的场景选择合适的选项和参数。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <unistd.h>

struct message {
    long mtype;
    char mtext[100];
};

int main() {
    key_t key = ftok("/tmp/msg_key", 1);  // 创建关联键
    int msgflg = IPC_CREAT | 0666;        // 创建标志和权限

    int msqid = msgget(key, msgflg);
    if (msqid == -1) {
        perror("msgget");
        exit(EXIT_FAILURE);
    }

    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    } else if (pid == 0) {
        // 子进程发送消息
        struct message msg;
        msg.mtype = 1;
        strcpy(msg.mtext, "Hello from child!");

        if (msgsnd(msqid, &msg, sizeof(struct message) - sizeof(long), 0) == -1) {
            perror("msgsnd");
            exit(EXIT_FAILURE);
        }
        printf("Child process sent message.\n");
    } else {
        // 父进程接收消息
        struct message msg;

        if (msgrcv(msqid, &msg, sizeof(struct message) - sizeof(long), 0, 0) == -1) {
            perror("msgrcv");
            exit(EXIT_FAILURE);
        }
        printf("Parent process received message: %s\n", msg.mtext);
    }

    return 0;
}
```

在这个示例中，父进程创建了一个消息队列，然后创建了一个子进程。子进程发送一条消息到消息队列，而父进程从消息队列接收消息。这样，通过消息队列实现了子进程和父进程之间的通信。请注意，这只是一个简单的示例，实际应用中可能需要更多的错误处理和完善的逻辑。

--------------------------

#### 信号量集 ` sys/ipc.h `

##### `semget` 函数

`semget` 是 System V IPC 中用于创建或获取信号量集的函数。信号量集允许你创建多个信号量，并且可以同时进行操作。下面是 `semget` 函数的函数原型、返回值和参数：

函数原型：

```
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int semget(key_t key, int nsems, int semflg);
```

返回值：

- 成功时返回信号量集的标识符（非负整数），失败时返回 -1。

参数：

- `key`：用于标识信号量集的键值，可以使用 `ftok` 函数生成。
- `nsems`：指定要创建或获取的信号量数量。
- `semflg`：创建或获取信号量的标志，通常使用 `IPC_CREAT` 来创建。常用:`IPC_CREAT | IPC_EXCL | 0666`
  - `IPC_CREAT`：如果不存在指定键值的信号量集，则创建一个新的。如果信号量集已经存在，则忽略该标志。
  - `IPC_EXCL`：与 `IPC_CREAT` 一起使用时，如果信号量集已经存在，则创建失败，返回错误。
  - `IPC_NOWAIT`：在获取信号量集时，如果没有可用的资源，不会阻塞，而是立即返回错误。

示例用法：

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int main() {
    key_t key = ftok("/tmp/sem_key", 1);  // 创建关联键
    int semflg = IPC_CREAT | IPC_EXCL | 0666; // 创建标志和权限

    int semid = semget(key, 1, semflg);   // 尝试创建一个信号量集

    if (semid == -1) {
        // 信号量已存在，重新获取并初始化
        semid = semget(key, 1, 0666); // 打开信号量集
        if (semid == -1) {
            perror("semget");
            exit(EXIT_FAILURE);
        }

        // 初始化信号量
        struct sembuf init_op;
        init_op.sem_num = 0;     // 操作的信号量编号
        init_op.sem_op = 1;      // 增加信号量的值
        init_op.sem_flg = 0;     // 操作标志
        if (semop(semid, &init_op, 1) == -1) {
            perror("semop");
            exit(EXIT_FAILURE);
        }

        printf("Semaphore already existed, opened and initialized.\n");
    } else {
        // 信号量不存在，创建并初始化
        printf("Semaphore created and initialized.\n");
    }

    return 0;
}
```



在这个示例中，我们使用 `semget` 函数创建了一个包含一个信号量的信号量集。`key` 是一个关联键，用于标识这个信号量集。`nsems` 参数指定信号量集中的信号量数量，这里我们只创建了一个信号量。`semflg` 参数设置了创建标志和权限。

注意：System V IPC 通常在现代的系统中不再使用，因为它的机制较为复杂，而且不支持跨平台。更推荐使用 POSIX 信号量等更现代的 IPC 机制配合共享内存完成同步与互斥。

--------------------------

##### `semctl`函数

用于初始化，删除信号量等~

`semctl` 是 System V IPC 机制中的一个函数，用于对信号量集进行控制操作。通过 `semctl` 函数，可以获取、设置或删除信号量集的信息，以及执行其他控制操作。以下是 `semctl` 函数的详细介绍：

函数原型：

```
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int semctl(int semid, int semnum, int cmd, ...);
```

参数：

- `semid`：信号量集的标识符，由 `semget` 函数返回。
- `semnum`：信号量的编号，指定要操作的信号量在信号量集中的位置。
- cmd：指定要执行的操作，可以是以下之一：
  - `IPC_RMID`：删除信号量集。
  - `GETVAL`：获取信号量的值。
  - `SETVAL`：设置信号量的值。
  - 其他与信号量操作相关的控制命令。

返回值：

- 成功时，根据不同的操作返回相应的值，通常是一个非负整数。
- 失败时返回 -1，并设置 `errno` 表示错误类型。

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int main() {
    key_t key = ftok("/tmp/sem_key", 1);  // 创建关联键
    int semflg = IPC_CREAT | 0666;        // 创建标志和权限

    int semid = semget(key, 1, semflg);   // 创建一个信号量集，包含一个信号量

    if (semid == -1) {
        perror("semget");
        exit(EXIT_FAILURE);
    }

    // 设置信号量的值为 42
    int set_val = 42;
    if (semctl(semid, 0, SETVAL, set_val) == -1) {
        perror("semctl");
        exit(EXIT_FAILURE);
    }

    // 获取信号量的值并打印
    int get_val = semctl(semid, 0, GETVAL);
    printf("Semaphore value: %d\n", get_val);

    // 删除信号量集
    if (semctl(semid, 0, IPC_RMID) == -1) {
        perror("semctl");
        exit(EXIT_FAILURE);
    }

    return 0;
}
```

demo2

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

// 定义 semun 联合体
union semun {
    int val;                // SETVAL 操作的值
    struct semid_ds *buf;   // IPC_STAT、IPC_SET 操作的缓冲区
    unsigned short *array;  // GETALL、SETALL 操作的数组
};

int main() {
    key_t key = ftok("/tmp/sem_key", 1);  // 创建关联键
    int semflg = IPC_CREAT | 0666;        // 创建标志和权限

    int semid = semget(key, 1, semflg);   // 创建一个信号量集，包含一个信号量

    if (semid == -1) {
        perror("semget");
        exit(EXIT_FAILURE);
    }

    // 初始化一个 semun 联合体，用于设置信号量的值
    union semun semarg;
    semarg.val = 5;

    // 设置信号量的值为 5
    if (semctl(semid, 0, SETVAL, semarg) == -1) {
        perror("semctl");
        exit(EXIT_FAILURE);
    }

    // 获取信号量的值并打印
    int get_val = semctl(semid, 0, GETVAL);
    printf("Semaphore value: %d\n", get_val);

    return 0;
}
```

---------------

##### `semop`函数

`semop` 是 System V IPC 机制中用于对信号量集执行操作的函数。它可以用来对信号量集进行 P（等待）操作和 V（发信号）操作，以实现进程或线程之间的同步和互斥。`semop` 函数可以同时操作多个信号量，执行一系列的操作。

函数原型：

```
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int semop(int semid, struct sembuf *sops, size_t nsops);
```

参数：

- `semid`：信号量集的标识符，由 `semget` 函数返回。
- `sops`：一个指向 `struct sembuf` 数组的指针，表示要执行的操作。
- `nsops`：指定操作的数量，即 `sops` 数组的元素个数。

`struct sembuf` 结构体定义如下：

```
struct sembuf {
    unsigned short sem_num;  // 信号量编号
    short sem_op;            // 操作值，正数表示 V 操作，负数表示 P 操作
    short sem_flg;           // 操作标志，通常为 0 或 IPC_NOWAIT
};
```

操作值 `sem_op` 为正数时表示 V（发信号）操作，为负数时表示 P（等待）操作。操作标志 `sem_flg` 可以设置为 0（阻塞等待）或 `IPC_NOWAIT`（非阻塞等待）。

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int main() {
    key_t key = ftok("/tmp/sem_key", 1);  // 创建关联键
    int semflg = IPC_CREAT | 0666;        // 创建标志和权限

    int semid = semget(key, 1, semflg);   // 创建一个信号量集，包含一个信号量

    if (semid == -1) {
        perror("semget");
        exit(EXIT_FAILURE);
    }

    // 准备操作数组
    struct sembuf semops[1];
    semops[0].sem_num = 0;   // 操作的信号量编号
    semops[0].sem_op = -1;   // 执行 P（等待）操作
    semops[0].sem_flg = 0;   // 操作标志

    // 执行操作
    if (semop(semid, semops, 1) == -1) {
        perror("semop");
        exit(EXIT_FAILURE);
    }

    printf("Semaphore operation complete.\n");

    return 0;
}
```







----------------------

--------------------

## 多线程编程基础

通过fork创建进程的时候，子进程是将父进程几乎所有的数据都进程了拷贝，有的数据几乎用不到。有时候我们只是希望子进程去完成一个很简单的任务，完全可以和父进程共享一片内存区域。很多操作系统引入了轻量级进程（ Lightweight Process ）：LWP。 在 Linux 中，`LWP` 通常指的是内核级别的线程（Kernel-level Thread）或进程中的实际执行单元。在某些情况下，一个进程内的每个线程（包括主线程）都被称为一个 LWP。LWP 可以由操作系统内核调度并运行，但它们通常与用户态线程库（如 POSIX 线程库）结合使用，以提供更高层次的线程管理和抽象。同一进程中的线程共享相同的地址空间。

同一进程下线程共享的资源

1. **地址空间**：所有线程共享同一进程的地址空间，包括代码段、数据段、堆和栈。这意味着线程可以直接访问进程内的所有变量和数据。
2. **全局变量**：线程可以访问进程中的全局变量，因为这些变量存在于进程的数据段中，对所有线程可见。
3. **堆内存**：所有线程可以在堆中分配和释放内存。多个线程可以共享堆中的数据。
4. **文件描述符**：文件描述符是操作系统对文件和输入/输出的抽象。线程可以共享进程的文件描述符，从而共享对文件和流的访问。
5. **信号处理器**：信号处理器是为了处理操作系统发出的信号，例如中断、错误等。多个线程可以共享相同的信号处理器。
6. **只读段**：只读的代码段和常量数据段是线程可以共享的，因为它们通常不会被线程修改。
7. **代码段**：所有线程共享相同的代码段，这意味着它们运行相同的程序代码。
8. **工作目录（Working Directory）**：工作目录是进程当前所在的目录。在同一进程内的所有线程共享相同的工作目录。如果一个线程修改了工作目录，那么这个变化将影响到进程中的所有线程。
9. **用户ID（UID）和用户组ID（GID）**：用户ID和用户组ID标识了进程的用户和用户组。在同一进程内的所有线程通常共享相同的用户ID和用户组ID。这些标识决定了进程对文件和资源的访问权限。

同一进程下线程私有资源

1. **线程ID（Thread ID）**：每个线程都有自己的线程ID，用于标识线程。线程ID在同一进程内是唯一的，不会与其他线程共享。
2. **错误号（Error Number）**：错误号是一个全局的整数，用于指示错误的类型。每个线程在执行系统调用或库函数时可能会设置自己的错误号，但错误号通常是线程私有的，不会与其他线程共享。
3. **优先级（Priority）**：某些操作系统允许线程设置自己的优先级，以影响调度顺序。优先级通常是线程私有的，每个线程可以单独设置自己的优先级。
4. **执行状态（Execution State）**：线程的执行状态，如运行、就绪、阻塞等，是线程私有的。每个线程根据自己的执行情况设置自己的状态。
5.  **线程属性（Thread Attributes）**： 
   **栈大小（Stack Size）**：线程的栈空间大小，用于存储局部变量和函数调用信息。
   **优先级（Priority）**：线程的调度优先级，影响线程获得 CPU 时间片的顺序。
   **调度策略（Scheduling Policy）**：线程的调度方式，如轮转、先来先服务等。
   **信号掩码（Signal Mask）**：线程处理信号的方式，包括哪些信号被阻塞或处理。
   **线程局部存储（Thread-Local Storage，TLS）**：允许线程创建自己的私有数据。
   **线程名称（Thread Name）**：用于标识线程的可读名称。



线程和进程对比

1. **开销**：
   - 进程：由于进程之间是相互独立的，创建和销毁进程需要较多的系统开销。进程切换需要保存和恢复完整的进程上下文，因此进程切换的开销较大。
   - 线程：线程是进程内的执行单元，因此创建和销毁线程的开销相对较小。线程切换的开销较进程切换要小，因为只需切换线程的部分上下文。
2. **内存占用**：
   - 进程：由于进程之间是隔离的，每个进程都拥有自己的地址空间、代码段、数据段和堆栈，因此进程的内存占用较大。每个进程都需要加载和维护独立的资源，这可能导致资源浪费。
   - 线程：线程共享同一进程的资源，包括代码段、数据段和堆，因此线程的内存占用相对较小。但要注意，线程共享资源也可能引发同步和竞争问题。
3. **切换开销**：
   - 进程：进程切换的开销较大，需要切换完整的进程上下文，包括虚拟内存映射、寄存器状态等。
   - 线程：线程切换的开销相对较小，因为线程共享进程的资源，只需要切换线程的部分上下文。
4. **适用场景**：
   - 进程：适用于需要隔离的环境，如运行多个不相关的应用程序，或者需要在不同的地址空间中运行不同的代码。
   - 线程：适用于需要共享数据和通信的情况，如提高并发性能、在同一进程内运行多个任务。

c语言的线程属于内核级线程，在某些情况下看待内核级线程，还是略重了。线程处理的某些特定业务时真正所使用的内存非常小，但是分配的内存却非常大，但是这些特定业务的并发量却非常的高。go语言为了解决这个问题实现了用户级线程库：协程，同样的机器比内核级线程并发量更高。java的高版本jdk也有类似的用户级线程。

---------------

##  POSIX 线程库`pthread.h`

### 创建线程:`pthread_create`

```
#include <pthread.h>

int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine)(void*), void *arg);
```

参数说明：

- `thread`：指向 `pthread_t` 类型的指针，用于存储新线程的标识符。
- `attr`：指向 `pthread_attr_t` 类型的指针，用于指定新线程的属性。可以传递 `NULL`，表示使用默认属性。
- `start_routine`：函数指针，指向新线程将要执行的函数。该函数应该接受一个 `void*` 参数并返回一个 `void*`。
- `arg`：传递给 `start_routine` 函数的参数。

函数返回值：

- 如果成功创建线程，函数返回 0。
- 如果出现错误，返回一个非零错误码，可以使用 `errno` 变量查看具体的错误信息。

---------------

### 等待线程:`pthread_join`

等待某个线程结束并获取其返回的值

```
#include <pthread.h>

int pthread_join(pthread_t thread, void **retval);
```

参数说明：

- `thread`：要等待的线程的标识符，通常是由 `pthread_create` 返回的线程标识符。
- `retval`：一个指向指针的指针，用于存储被等待线程的返回值。如果不关心返回值，可以传递 `NULL`。
  传入一个指针的地址，将这个指针指向数据修改为指向堆内存地址，之后可以直接使用这个指针获得返回数据。

函数返回值：

- 如果成功等待线程结束，函数返回 0。
- 如果出现错误，返回一个非零错误码，可以使用 `errno` 变量查看具体的错误信息。



---------------

### 结束线程:`pthread_exit`

用于向其他线程返回数据，同时结束本线程

 主线程的结束不会自动终止其他线程。主线程的结束只表示主线程的执行已经完成，但其他线程仍然可以继续执行。只有当所有线程都执行完毕或调用了 `pthread_exit` 来终止自己时，整个进程才会终止。 `pthread_exit`在线程内使用,如果有返回值则将返回值的地址放入其中,如果某个线程对这个线程使用了`pthread_join`然后获得这个返回的地址值。

c线程结束会自动回收栈资源等==>但是堆内存需要妥善管理。

```
#include <pthread.h>

void pthread_exit(void *retval);
```

参数说明：

- `retval`：线程的退出状态，可以是任何类型的指针。可以通过其他线程使用 `pthread_join` 来获取这个退出状态。

```c
#include <stdio.h>
#include <pthread.h>

void *thread_function(void *arg) {
    int *value = malloc(sizeof(int));
    *value = 42;
    pthread_exit(value);
}

int main() {
    pthread_t thread;
    int result;

    result = pthread_create(&thread, NULL, thread_function, NULL);
    if (result != 0) {
        perror("Thread creation failed");
        return 1;
    }

    void *thread_result;
    result = pthread_join(thread, &thread_result);
    if (result != 0) {
        perror("Thread join failed");
        return 1;
    }

    int *value_from_thread = (int *)thread_result;
    printf("Thread returned: %d\n", *value_from_thread);

    free(value_from_thread);

    return 0;
}
```

---------------

### pthread_attr_t 相关函数

`pthread_attr_t` 是线程属性对象的类型，用于在创建线程时设置线程的属性。通过 `pthread_attr_t`，你可以指定线程的一些特性，如栈大小、分离状态、调度策略等。

以下是一些常用的 `pthread_attr_t` 相关函数和操作：

1. **`pthread_attr_init`：** 用于初始化线程属性对象。

   ```
    int pthread_attr_init(pthread_attr_t *attr);
   ```

2. **`pthread_attr_destroy`：** 用于销毁线程属性对象。

   ```
    int pthread_attr_destroy(pthread_attr_t *attr);
   ```

3. **`pthread_attr_setdetachstate`：** 用于设置线程的分离状态（分离或非分离）。

   ```
    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
   ```

   - `detachstate`：`PTHREAD_CREATE_DETACHED`（分离状态）或 `PTHREAD_CREATE_JOINABLE`（非分离状态）。

4. **`pthread_attr_getdetachstate`：** 用于获取线程的分离状态。

   ```
    int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);
   ```

5. **`pthread_attr_setstacksize`：** 用于设置线程栈的大小。

   ```
    int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
   ```

6. **`pthread_attr_getstacksize`：** 用于获取线程栈的大小。

   ```
    int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize);
   ```

7. **`pthread_attr_setschedpolicy` 和 `pthread_attr_getschedpolicy`：** 用于设置和获取线程的调度策略。

   ```
    int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy);
   int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy);
   ```

8. **`pthread_attr_setschedparam` 和 `pthread_attr_getschedparam`：** 用于设置和获取线程的调度参数。

   ```
    int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param);
   int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param);
   ```



---------------

### 其他函数

1. **`pthread_detach`：** 将指定的线程标记为分离状态，使线程在结束后自动释放资源,不能再使用pthread_join获得返回值,因为已经处于分离状态,某些不需要返回数据的线程可以使用这个函数进行设置防止内存泄漏。

   ```
    int pthread_detach(pthread_t thread);
   ```

   提前设置为分离状态

   ```c
   #include <stdio.h>
   #include <pthread.h>
   
   void *thread_function(void *arg) {
       printf("Thread is executing...\n");
       // 执行线程任务
       return NULL;
   }
   
   int main() {
       pthread_t thread;
       int result;
   
       // 创建线程并将其标记为分离状态
       pthread_attr_t attr;
       pthread_attr_init(&attr);
       pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
   
       result = pthread_create(&thread, &attr, thread_function, NULL);
       if (result != 0) {
           perror("Thread creation failed");
           return 1;
       }
   
       // 释放线程属性对象
       pthread_attr_destroy(&attr);
   
       printf("Main thread continuing...\n");
   
       // 主线程继续执行其他任务
       // 无需等待分离线程结束
   
       return 0;
   }
   ```

   

2. **`pthread_cancel`：** 用于取消指定的线程。

   ```
    int pthread_cancel(pthread_t thread);
   ```

3. **`pthread_mutex_init` 和 `pthread_mutex_destroy`：** 用于初始化和销毁互斥锁。

   ```
    int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
   int pthread_mutex_destroy(pthread_mutex_t *mutex);
   ```

4. **`pthread_mutex_lock` 和 `pthread_mutex_unlock`：** 用于加锁和解锁互斥锁。

   ```
    int pthread_mutex_lock(pthread_mutex_t *mutex);
   int pthread_mutex_unlock(pthread_mutex_t *mutex);
   ```

5. **`pthread_cond_init` 和 `pthread_cond_destroy`：** 用于初始化和销毁条件变量。

   ```
    int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);
   int pthread_cond_destroy(pthread_cond_t *cond);
   ```

6. **`pthread_cond_wait` 和 `pthread_cond_signal`：** 用于等待条件变量满足和发送信号。

   ```
    int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
   int pthread_cond_signal(pthread_cond_t *cond);
   ```

7. **`pthread_barrier_init` 和 `pthread_barrier_destroy`：** 用于初始化和销毁屏障。

   ```
    int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count);
   int pthread_barrier_destroy(pthread_barrier_t *barrier);
   ```

8. **`pthread_barrier_wait`：** 用于等待屏障，直到所有线程都到达屏障点。

   ```
    int pthread_barrier_wait(pthread_barrier_t *barrier);
   ```





---------------

---------------

## 线程间的通信问题

线程共享统一进程的地址空间,使得线程之间通信变得很方便,而线程间通信则需要做好线程互斥,同步等问题

信号量

- 初始化信号量==>资源数量
- P操作==>申请资源,如果有资源则资源-1,没有则阻塞 也称为 "Proberen" 操作（荷兰语，意为 "试探"） 
- V操作==>释放资源,释放资源,资源+1 也称为 "Verhogen" 操作（荷兰语，意为 "增加"）

---------------

### 信号量相关函数 `semaphore.h`

信号量是一种同步机制，可以用来解决线程/进程的同步问题，同时也能解决互斥问题

#### `sem_init` 函数

`sem_init` 函数是 POSIX 线程库中用于初始化一个信号量的函数。它用于创建一个新的信号量，并设置其初始值。信号量通常用于线程间的同步和互斥操作。

函数原型：

```
int sem_init(sem_t *sem, int pshared, unsigned int value);
```

参数解释：

- `sem`：指向要初始化的信号量的指针。
- `pshared`：指定信号量是否可以在进程之间共享。通常设置为 0（信号量只能在同一进程的线程间共享）1则为进程间。
- `value`：信号量的初始值。

返回值：

- 成功：返回 0。
- 失败：返回 -1，并设置 `errno`。

```c
#include <stdio.h>
#include <semaphore.h>

int main() {
    sem_t my_semaphore;
    int result;

    // 初始化信号量，初始值为 1
    result = sem_init(&my_semaphore, 0, 1);
    if (result != 0) {
        perror("Semaphore initialization failed");
        return 1;
    }

    // 使用信号量进行同步或互斥操作

    // 销毁信号量
    sem_destroy(&my_semaphore);

    return 0;
}
```

---------------

#### `sem_wait`函数

`sem_wait` 是一个用于信号量操作的函数，用于在信号量上执行 P（原语）操作。它会尝试减少信号量的值，如果信号量的值大于零，则会成功执行减少操作；如果信号量的值为零，则会**阻塞**，直到信号量的值大于零为止。

函数原型：

```
int sem_wait(sem_t *sem);
```

参数解释：

- `sem`：指向要进行操作的信号量的指针。

返回值：

- 成功：返回 0。
- 失败：返回 -1，并设置 `errno`。

---------------

#### `sem_post` 函数

`sem_post` 是一个用于信号量操作的函数，用于在信号量上执行 V（释放）操作。它会增加信号量的值，从而释放之前由 P 操作（`sem_wait`）占用的资源。

函数原型：

```
int sem_post(sem_t *sem);
```

参数解释：

- `sem`：指向要进行操作的信号量的指针。

返回值：

- 成功：返回 0。
- 失败：返回 -1，并设置 `errno`。

---------------

####  `sem_destroy` 函数 

一般一个信号量,在整个进程运行需要一直保持存在,进程结束会自动释放资源,销毁信号量看起来可有可无,但是也有可能会出现非要使用这个函数不可的时候!

销毁信号量的过程可以通过调用 `sem_destroy` 函数来完成。这个函数会释放信号量占用的资源并将其销毁。在销毁信号量之前，确保所有使用该信号量的线程或进程都已经完成对信号量的操作，以避免出现问题。

函数原型：

```
int sem_destroy(sem_t *sem);
```

参数解释：

- `sem`：指向要销毁的信号量的指针。

返回值：

- 成功：返回 0。
- 失败：返回 -1，并设置 `errno`。





---------------

### 线程同步与互斥解决

```
同步则要求对于某些代码段a线程先执行,b才能执行==>a执行后才会有资源,b才能执行
a:
	代码
	v操作==>有资源

b:
	p操作==>获取资源
	被保护的代码段

```

```
pv操作解决:互斥则要求同一资源只能够同时被一个线程访问

a:
	p操作==>申请访问资源
	代码
	v操作==>归还资源
b:
	p操作==>申请访问资源
	代码
	v操作==>归还资源
```

```
posix的线程库提供了解决互斥的功能:

    初始化锁
    {
        获得锁
        访问资源
        归还锁
    }
    销毁锁

```



#### `pthread_mutex_init`函数: `pthread.h`

`pthread_mutex_init` 函数用于初始化互斥锁（Mutex），为互斥锁分配资源并设置它的属性。在使用互斥锁之前，通常需要调用这个函数进行初始化。

函数原型：

```
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
```

参数解释：

- `mutex`：指向要初始化的互斥锁的指针。
- `attr`：指向一个互斥锁属性的指针，通常设置为 `NULL` 表示使用默认属性。

返回值：

- 成功：返回 0。
- 失败：返回错误码，并设置 `errno`。



---------------

#### `pthread_mutex_lock`函数:`pthread.h`

`pthread_mutex_lock` 函数是 POSIX 线程库中用于对互斥锁（Mutex）进行加锁操作的函数。互斥锁用于保护共享资源，以确保在同一时刻只有一个线程可以访问这些资源，从而防止竞争条件。没有资源阻塞

函数原型：

```
int pthread_mutex_lock(pthread_mutex_t *mutex);
```

参数解释：

- `mutex`：指向要加锁的互斥锁的指针。

返回值：

- 成功：返回 0。
- 失败：返回错误码，并设置 `errno`。



---------------

#### `pthread_mutex_unlock`函数:`pthread.h`

`pthread_mutex_unlock` 函数是 POSIX 线程库中用于对互斥锁进行解锁操作的函数。互斥锁用于保护共享资源，当一个线程完成对共享资源的访问后，应该使用该函数来释放互斥锁，以允许其他线程访问共享资源。

函数原型：

```
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

参数解释：

- `mutex`：指向要解锁的互斥锁的指针。

返回值：

- 成功：返回 0。
- 失败：返回错误码，并设置 `errno`。



---------------

#### `pthread_mutex_destroy`函数:`pthread.h`

`pthread_mutex_destroy` 函数用于销毁一个已经初始化的互斥锁（Mutex）。在不再需要使用互斥锁时，应该调用该函数释放互斥锁占用的资源。

函数原型：

```
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

参数解释：

- `mutex`：指向要销毁的互斥锁的指针。

返回值：

- 成功：返回 0。
- 失败：返回错误码，并设置 `errno`。



```c
#include <stdio.h>
#include <pthread.h>

pthread_mutex_t my_mutex = PTHREAD_MUTEX_INITIALIZER;
//使用了 PTHREAD_MUTEX_INITIALIZER 来初始化互斥锁。这种初始化方式适用于静态初始化，它在编译时为互斥锁分配了必要的资源，并将互斥锁初始化为默认属性。也可以在main内进行初始化
int shared_variable = 0;

void *thread_function(void *arg)
{
    // 加锁
    pthread_mutex_lock(&my_mutex);

    // 访问共享资源
    for (int i = 0; i < 5; i++)
    {
        shared_variable++;
        printf("Thread %d: shared_variable = %d\n", *(int *)arg, shared_variable);
    }

    // 解锁
    pthread_mutex_unlock(&my_mutex);

    return NULL;
}

int main()
{
    pthread_t thread1, thread2;
    int thread_id1 = 1, thread_id2 = 2;

    // 创建线程
    pthread_create(&thread1, NULL, thread_function, &thread_id1);
    pthread_create(&thread2, NULL, thread_function, &thread_id2);

    // 等待线程结束
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    // 销毁互斥锁
    pthread_mutex_destroy(&my_mutex);

    return 0;
}
```

---------------

