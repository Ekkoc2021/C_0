# 网络编程



- 流式套接字(SOCK_STREAM)==>tcp

–提供了一个面向连接、可靠的数据传输服务，数据无差错、无重复的发送且按发送顺序接收。内设置流量控制，避免数据流淹没慢的接收方。数据被看作是字节流，无长度限制。

- 数据报套接字(SOCK_DGRAM)==>udp

提供无连接服务。数据包以独立数据包的形式被发送，不提供无差错保证，数据可能丢失或重复，顺序发送，可能乱序接收。

- 原始套接字(SOCK_RAW)==>本地

可以对较低层次协议如IP、ICMP直接访问。



## 字节序

字节序（Byte Order）是计算机存储多字节数据（如整数、浮点数）的方式，它决定了多字节数据的字节排列顺序。在计算机中，字节是基本的数据存储单元，多字节数据（如16位整数、32位浮点数等）通常由多个字节组成。

在计算机中，有两种常见的字节序方式：

1. **大端字节序（Big-Endian）：** 在大端字节序中，多字节数据的高位字节（最高有效字节）存储在低地址内存中，而低位字节（最低有效字节）存储在高地址内存中。这意味着数据的左侧部分存储在低地址，右侧部分存储在高地址。
2. **小端字节序（Little-Endian）：** 在小端字节序中，多字节数据的高位字节存储在高地址内存中，而低位字节存储在低地址内存中。这意味着数据的左侧部分存储在高地址，右侧部分存储在低地址。

网络字节序（Network Byte Order）是一种特定的字节序，通常采用大端字节序（Big-Endian），用于在不同计算机系统之间进行数据交换和通信。网络字节序的定义是为了确保跨不同体系结构的计算机之间能够正确地解释和传递二进制数据。 

计算机体系结构和操作系统可能采用不同的字节序，因此在进行网络编程时需要注意字节序的问题，以确保数据被正确解释。

比如传输int类型(32比特,4字节)，需要确保本地字节序列和网络字节序一致，才能确保对方收到的数据是正确的数据。 

操作系统实现了本地字节序和网络字节序转换的函数，程序员不必知道本地采用何种字节序，传输数据不是单字节的，则使用特定的函数进行转换为网络字节序即可，接收数据时也是一样。



### 本地转网络`arpa/inet.h`

几乎所有复杂的数据类型都是由基本数据类型构成，下面这几个函数已经能够满足需求!

#### `htonl` 函数

Host to Network Long

- 函数原型：

  ```
  u_long htonl(u_long hostlong);
  ```

- **用法：** `htonl` 用于将32位整数从主机字节序转换为网络字节序（大端字节序）。

- **返回值：** 返回转换后的网络字节序的32位整数。

- 参数：

  - `hostlong`：要转换的32位整数，以主机字节序表示。

**示例用法：**

```c
#include <arpa/inet.h>

u_long hostValue = 0x12345678; // 主机字节序表示
u_long networkValue = htonl(hostValue); // 转换为网络字节序
```

#### `htons` 函数

Host to Network Short

- 函数原型：

  ```
  u_short htons(u_short hostshort);
  ```

- **用法：** `htons` 用于将16位整数从主机字节序转换为网络字节序（大端字节序）。

- **返回值：** 返回转换后的网络字节序的16位整数。

- 参数：

  - `hostshort`：要转换的16位整数，以主机字节序表示。

**示例用法：**

```c
#include <arpa/inet.h>

u_short hostValue = 0x1234; // 主机字节序表示
u_short networkValue = htons(hostValue); // 转换为网络字节序
```

#### `htonll`函数

Host to Network  Long Long

`uint64_t htonll(uint64_t hostlonglong);` 函数用于将64位整数（`uint64_t` 类型）从主机字节序转换为网络字节序（大端字节序）。以下是该函数的函数原型、返回值、参数的详细说明：

- **函数原型：**

  ```
  codeuint64_t htonll(uint64_t hostlonglong);
  ```

- **返回值：**

  - `htonll` 函数返回一个 `uint64_t` 类型的值，表示64位整数在网络字节序中的表示。

- **参数：**

  - `hostlonglong`：要转换的64位整数，以主机字节序表示。

- **功能描述：**

  - `htonll` 函数接受一个64位整数 `hostlonglong`，该整数表示为主机字节序（通常是主机的本地字节序）。然后，它将该整数值转换为网络字节序（大端字节序）并返回结果。



### 网络转本地 `arpa/inet.h`

#### `ntohs` 函数

Network to Host Short

用于将16位整数从网络字节序转换为主机字节序。

```
#include <arpa/inet.h>

u_short networkValue = 0x1234; // 网络字节序
u_short hostValue = ntohs(networkValue); // 转换为主机字节序
```

#### `ntohl` 函数

Network to Host Long

用于将32位整数从网络字节序转换为主机字节序。

```
#include <arpa/inet.h>

u_long networkValue = 0x12345678; // 网络字节序
u_long hostValue = ntohl(networkValue); // 转换为主机字节序
```

#### `ntohll` 函数

Network to Host Long Long

用于将64位整数从网络字节序转换为主机字节序。

```
#include <arpa/inet.h>

uint64_t networkValue = 0x1234567890ABCDEFULL; // 网络字节序
uint64_t hostValue = ntohll(networkValue); // 转换为主机字节序
```

这些函数与之前介绍的 `htonl`、`htons`、`htonll` 函数相对应，它们将网络字节序数据转换为主机字节序，以确保在本地计算机上正确解释数据。这些函数通常在网络编程中用于处理接收到的网络数据，以便将其转换为本地字节序。



## 网络编程API

- –socket()　创建套接字
- bind()　绑定本机地址和端口
- connect()　建立连接
- listen()　设置监听端口
- accept()　接受TCP连接
- recv(), read(), recvfrom()　数据接收
- send(), write(), sendto()　数据发送
- close(), shutdown()　关闭套接字

另外还有地址转换函数==>点分十进制转为ipv4网络字节序的ip地址,ipv4网络字节序转点分十进制

#### `socket` 函数`sys/socket.h`

- 函数原型：

  ```
  int socket(int domain, int type, int protocol);
  ```

- 参数：

  - `domain` 参数指定套接字的协议域（协议族），通常为以下之一：
    - `AF_INET`：IPv4 协议族。
    - `AF_INET6`：IPv6 协议族。
    - `AF_UNIX` 或 `AF_LOCAL`：Unix 域协议族（用于本地通信）。
    - 其他协议族，具体取决于操作系统支持的协议。
  - `type` 参数指定套接字的类型，通常为以下之一：
    - `SOCK_STREAM`：流套接字，用于可靠的面向连接的通信，如 TCP。
    - `SOCK_DGRAM`：数据报套接字，用于不可靠的无连接通信，如 UDP。
    - 其他套接字类型，具体取决于操作系统支持的类型。SOCK_STREAM / SOCK_DGRAM / SOCK_RAW 
  - `protocol` 参数指定套接字使用的协议，**通常为 0** 表示自动选择与 `type` 相关的默认协议。但也可以指定具体的协议，例如：
    - `IPPROTO_TCP`：TCP 协议。
    - `IPPROTO_UDP`：UDP 协议。
    - 其他协议，具体取决于操作系统支持的协议。

  返回值：

  - 如果函数成功创建套接字，返回一个非负整数，表示套接字的文件描述符（Socket Descriptor）。
  - 如果函数失败，返回 -1，并设置全局变量 `errno` 以指示错误的原因

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <sys/types.h>
  #include <sys/socket.h>
  #include <netinet/in.h>
  
  int main() {
      int sockfd; // 套接字描述符
  
      // 创建一个IPv4的TCP套接字
      sockfd = socket(AF_INET, SOCK_STREAM, 0);
  
      if (sockfd == -1) {
          perror("socket");
          exit(EXIT_FAILURE);
      }
  
      // 在这里可以使用 sockfd 进行其他操作，如绑定、连接、发送和接收数据等
  
      // 关闭套接字
      close(sockfd);
  
      return 0;
  }
  ```

#### `inet_addr`函数 `arpa/inet.h `

`inet_addr` 是一个用于将点分十进制表示法的IPv4地址字符串转换为32位二进制整数表示的函数。它通常在网络编程中用于将人类可读的IPv4地址转换为计算机可理解的格式。在绑定ip或者建立连接时都需要用到

函数原型如下：

```
in_addr_t inet_addr(const char *cp);
```

- `cp`：一个指向以点分十进制格式表示的IPv4地址字符串的指针。

返回值：

- 如果成功将输入的IPv4地址字符串转换为32位二进制整数表示，函数返回该整数（类型为 `in_addr_t`）。
- 如果字符串不是有效的IPv4地址表示法，函数返回 `INADDR_NONE`，通常是 `-1`，表示转换失败。

--------

#### `inet_pton` 函数 `arpa/inet.h`

`inet_pton` 是一个用于将点分十进制的IP地址转换为网络字节序的二进制形式的函数。它的原型如下：

```
#include <arpa/inet.h>

int inet_pton(int af, const char *src, void *dst);
```

- `af`：表示地址族（Address Family），通常是 `AF_INET`（IPv4）或 `AF_INET6`（IPv6）。
- `src`：是一个指向包含点分十进制IP地址的字符串的指针。
- `dst`：是一个指向用于存储二进制地址的内存缓冲区的指针。

`inet_pton` 函数的返回值是一个整数，它表示操作的结果。如果转换成功，它将返回1（表示成功），如果转换失败，它将返回0（表示无效的IP地址格式），如果发生错误，它将返回-1，并设置 `errno` 来指示错误类型。

```c
#include <stdio.h>
#include <arpa/inet.h>

int main() {
    const char *ip_address = "192.168.1.1";
    struct in_addr addr;

    if (inet_pton(AF_INET, ip_address, &addr) == 1) {
        printf("Converted IP address: 0x%X\n", addr.s_addr);
    } else {
        perror("inet_pton");
    }

    return 0;
}
```



----

#### `inet_ntoa` 函数 `arpa/inet.h`

`inet_ntoa` 是一个函数，用于将32位二进制整数表示的IPv4地址转换为点分十进制表示法的字符串。它通常在网络编程中用于将计算机内部使用的二进制表示的IPv4地址转换为人类可读的格式。

函数原型如下：

```
char *inet_ntoa(struct in_addr address);
```

- `address`：一个 `struct in_addr` 结构，其中包含32位的IPv4地址。

返回值：

- 如果成功将输入的IPv4地址转换为点分十进制字符串表示，函数返回一个指向结果字符串的指针。
- 如果发生错误，函数返回 `NULL`。

需要注意的是，`inet_ntoa` 函数的返回值是一个指向静态内存的指针，因此在多次调用该函数时，结果会被覆盖。为了安全起见，通常将结果字符串复制到一个缓冲区中，以防止数据被覆盖。

以下是一个示例用法：

```c
#include <stdio.h>
#include <arpa/inet.h>

int main() {
    struct in_addr ipv4_addr;
    ipv4_addr.s_addr = inet_addr("192.168.1.1"); // 将点分十进制字符串转换为32位二进制IPv4地址

    char *ipv4_str = inet_ntoa(ipv4_addr);

    if (ipv4_str != NULL) {
        printf("IPv4 Address in dotted-decimal notation: %s\n", ipv4_str);
    } else {
        perror("inet_ntoa");
    }

    return 0;
}
```

在上述示例中，我们将点分十进制表示的IPv4地址字符串转换为32位二进制表示的IPv4地址，然后使用 `inet_ntoa` 函数将其转换回点分十进制字符串进行打印。请注意，为了安全起见，可以将结果字符串复制到另一个缓冲区中，以免数据被覆盖。

---



#### `bind`函数`sys/socket.h`

 `bind()` 函数用于将套接字与本地地址和端口进行绑定，使套接字能够监听指定的端口或与指定的本地地址通信。通常在服务器端使用 `bind()` 来绑定监听套接字的地址和端口。 

- 函数原型：

  ```
  int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
  ```

- 参数：

  - `sockfd`：套接字描述符，通过 `socket()` 创建。

  - `addr`：包含本机地址和端口的 `struct sockaddr` 结构体的指针,注意不是传入结构体指针,由于ipv6和ipv4结构体长度不一致,所以最后还要指定一个长度标明长度。

    `struct sockaddr` 是一个通用的套接字地址结构体，用于在网络编程中表示套接字的地址信息。它是一个用于在不同协议族（如IPv4、IPv6、Unix域套接字等）之间通用的数据结构，可以根据具体情况进行类型转换，以适应不同的地址表示形式。

    `struct sockaddr` 的定义如下：

    ```c
    struct sockaddr {
        sa_family_t sa_family; // 地址的协议族 (AF_XXX)
        char sa_data[14];      // 地址数据
    };
    ```

    - `sa_family` 字段表示套接字地址的协议族（Address Family），通常是一个整数，用于区分不同的协议族。例如，`AF_INET` 表示IPv4，`AF_INET6` 表示IPv6，`AF_UNIX` 表示Unix域套接字等。这个字段告诉系统如何解释 `sa_data` 中的数据。
    - `sa_data` 字段是一个包含地址数据的字符数组，可以根据协议族的不同，存储不同类型的地址信息。例如，在IPv4中，`sa_data` 可以存储一个4字节的IPv4地址和2字节的端口号。

    由于 `struct sockaddr` 是一个通用的数据结构，通常在实际编程中不直接使用它，而是使用特定协议族的地址结构体（如 `struct sockaddr_in` 或 `struct sockaddr_in6`），然后通过类型转换将其转换为 `struct sockaddr`。这样做可以使代码更具可读性，并且更容易处理不同协议族的地址。

    **ipv4** `netinet/in.h`

    以下是 `struct sockaddr_in` 的定义，用于表示IPv4地址和端口：

    ```c
    struct sockaddr_in {
        sa_family_t sin_family; // AF_INET
        in_port_t sin_port;     // 16位端口号==>2字节
        struct in_addr sin_addr; // 32位IPv4地址==>4字节
        unsigned char sin_zero[8]; // 未使用的填充字节==>8字节
    };
    ```

    `struct in_addr` 是用于表示IPv4地址的数据结构，通常用于网络编程中。它的定义如下：

    ```c
    struct in_addr {
        in_addr_t s_addr; // 32位IPv4地址
    };
    ```

    - `s_addr` 是一个 32 位的整数，用于存储IPv4地址。通常，IPv4地址的表示采用点分十进制表示法，但在 `struct in_addr` 中，它以二进制格式存储。这个字段的名称 `s_addr` 代表 "socket address"。可以使用`inet_addr`函数转换点分10进制的ip地址

    在使用套接字函数时，你通常会创建特定协议族的地址结构体，然后将其转换为 `struct sockaddr`，以便将地址信息传递给函数，如 `bind()`、`connect()`、`accept()` 等。在函数内部，系统会根据 `sa_family` 字段来正确解释 `sa_data` 中的数据。

    **ipv6** `netinet/in.h`

    `struct sockaddr_in6` 是用于表示IPv6地址的套接字地址结构体，通常用于IPv6网络编程中。它的定义如下：

    ```c
    struct sockaddr_in6 {
        sa_family_t sin6_family;     // AF_INET6
        in_port_t sin6_port;         // 16位端口号
        uint32_t sin6_flowinfo;      // 流信息（通常设置为0）
        struct in6_addr sin6_addr;   // 128位IPv6地址
        uint32_t sin6_scope_id;      // 接口标识符（通常设置为0）
    };
    ```

    - `sin6_family` 字段表示套接字地址的协议族，通常为 `AF_INET6`，表示IPv6。
    - `sin6_port` 字段表示套接字的端口号，与IPv4相同，使用 `in_port_t` 类型。
    - `sin6_flowinfo` 字段用于流信息，通常设置为0，因为流信息在IPv6中不常用。
    - `sin6_addr` 字段是一个 `struct in6_addr` 结构，用于存储128位的IPv6地址。
    - `sin6_scope_id` 字段表示接口标识符，通常设置为0，用于区分多个具有相同IPv6地址的接口。

    以下是一个示例，演示如何创建和使用 `struct sockaddr_in6`：

    ```c
    #include <stdio.h>
    #include <netinet/in.h>
    
    int main() {
        struct sockaddr_in6 server_addr;
        memset(&server_addr, 0, sizeof(server_addr));
        server_addr.sin6_family = AF_INET6;
        server_addr.sin6_port = htons(8080); // 设置监听端口
    
        // 设置IPv6地址，使用 inet_pton 将IPv6地址的点分十六进制表示法转换为二进制
        inet_pton(AF_INET6, "2001:0db8:85a3:0000:0000:8a2e:0370:7334", &server_addr.sin6_addr);
    
        // 设置接口标识符，通常设置为0
        server_addr.sin6_scope_id = 0;
    
        // 在此之后，可以使用 server_addr 表示一个IPv6地址和端口的套接字地址
    
        return 0;
    }
    ```

    在实际编程中，你会经常使用 `struct sockaddr_in6` 来表示IPv6地址和端口，然后将其传递给套接字函数，如 `bind()`、`connect()`、`accept()` 等，以指定要使用的地址。

  - `addrlen`：`addr` 结构体的长度。

- 返回值：

  - 如果成功，返回 0。
  - 如果失败，返回 -1，并设置 `errno` 以指示错误。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h> // 定义了对应的结构体

int main() {
    int sockfd; // 套接字描述符
    struct sockaddr_in server_addr; // 服务器地址信息

    // 创建一个IPv4的TCP套接字
    sockfd = socket(AF_INET, SOCK_STREAM, 0);

    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 设置服务器地址结构体
    memset(&server_addr, 0, sizeof(server_addr)); // 清空结构体是必要的!
    
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080); // 设置监听端口
    server_addr.sin_addr.s_addr = INADDR_ANY; // 接受任意IP地址

    // 绑定套接字到指定地址和端口
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("bind");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    // 在这里可以进行监听和接受连接等操作

    // 关闭套接字
    close(sockfd);

    return 0;
}
```

通常只有服务器端需要使用 `bind` 函数，而客户端不需要显式绑定本地地址和端口。以下是解释原因的一些关键点：

1. **服务器端需要 `bind`**：服务器端通常需要使用 `bind` 函数来指定它监听的本地地址和端口。这是因为服务器要等待客户端的连接请求，因此需要指定服务器的地址和端口。服务器绑定后，可以使用 `listen` 开始监听连接请求。
2. **客户端通常不需要 `bind`**：客户端通常不需要显式绑定本地地址和端口。当客户端创建套接字后，操作系统会自动分配一个可用的本地端口，并且通常会绑定一个合适的本地地址。客户端通过调用 `connect` 函数连接到服务器，并且不需要显式绑定。
3. **操作系统自动处理客户端的本地地址和端口**：客户端的本地地址和端口通常由操作系统自动管理。这可以确保多个客户端可以在同一台计算机上同时连接到不同的远程服务器，而不会发生冲突。





----

#### `connect`函数  ` sys/socket.h`

 函数用于建立与远程服务器的连接 

- 函数原型：

  ```
  int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
  ```

- 参数：

  - `sockfd`：套接字描述符，通过 `socket()` 创建。
  - `addr`：包含目标服务器地址和端口的 `struct sockaddr` 结构体。同`bind函数`的参数一致。
  - `addrlen`：`addr` 结构体的长度。

- 返回值：

  - 如果成功，返回 0。
  - 如果失败，返回 -1，并设置 `errno` 以指示错误。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main() {
    int sockfd; // 套接字描述符
    struct sockaddr_in server_addr; // 服务器地址信息

    // 创建一个IPv4的TCP套接字
    sockfd = socket(AF_INET, SOCK_STREAM, 0);

    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 设置服务器地址结构体
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080); // 设置服务器端口
    server_addr.sin_addr.s_addr = inet_addr("192.168.1.1"); // 设置服务器IPv4地址

    // 连接到远程服务器
    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("connect");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    // 在此之后，你可以在 sockfd 上进行数据的发送和接收

    // 关闭套接字
    close(sockfd);

    return 0;
}
```

----



#### `listen`函数 `sys/socket.h`

 `listen()` 函数是在服务器端套接字上调用的函数，用于将套接字设置为监听模式，以接受客户端的连接请求。

 `listen()` 函数的主要作用是将套接字从初始状态（已创建但未设置为监听模式）切换到监听状态，以便服务器可以开始接受客户端的连接请求。一旦套接字处于监听状态，服务器可以使用 `accept()` 函数来接受客户端连接。 

- 函数原型：

  ```
  int listen(int sockfd, int backlog);
  ```

- 参数：

  - `sockfd`：套接字描述符，通过 `socket()` 创建，并绑定了一个地址。
  - `backlog`：等待连接队列的最大长度。

- 返回值：

  - 如果成功，返回 0。
  - 如果失败，返回 -1，并设置 `errno` 以指示错误。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

int main() {
    int sockfd; // 套接字描述符
    int backlog = 5; // 等待队列的最大长度

    // 创建一个IPv4的TCP套接字
    sockfd = socket(AF_INET, SOCK_STREAM, 0);

    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080); // 设置服务器端口
    server_addr.sin_addr.s_addr = INADDR_ANY; // 使用任意可用的本地地址

    // 绑定套接字到地址
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("bind");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    // 设置套接字为监听状态
    if (listen(sockfd, backlog) == -1) {
        perror("listen");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port 8080...\n");

    // 在此之后，可以使用 accept() 函数接受客户端连接

    return 0;
}
```

---

#### `accept`函数 `<sys/socket.h`

`accept()` - 接受TCP连接

- 函数原型：

  ```
  int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
  ```

- 参数：

  - `sockfd`：套接字描述符，通过 `socket()` 创建，并已经调用 `listen()`。
  - `addr`：用于存储客户端地址信息的 `struct sockaddr` 结构体。 `accept()` 函数会将客户端的地址信息填充到这个结构体中。 
  - `addrlen`：`addr` 结构体的长度，需要传递指向 `socklen_t` 类型的指针。

- 返回值：

  - 如果成功，返回一个新的套接字描述符，用于与客户端通信。
  - 如果失败，返回 -1，并设置 `errno` 以指示错误。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

int main() {
    int sockfd; // 原始套接字描述符
    int new_sock; // 新套接字描述符，用于与客户端通信==>文件描述符
    struct sockaddr_in server_addr;
    struct sockaddr_in client_addr;
    socklen_t client_addrlen;

    // 创建一个IPv4的TCP套接字
    sockfd = socket(AF_INET, SOCK_STREAM, 0);

    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080); // 设置服务器端口
    server_addr.sin_addr.s_addr = INADDR_ANY; // 使用任意可用的本地地址

    // 绑定套接字到地址
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("bind");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    // 设置套接字为监听状态，等待客户端连接请求
    if (listen(sockfd, 5) == -1) {
        perror("listen");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port 8080...\n");

    // 接受客户端连接
    client_addrlen = sizeof(client_addr);
    new_sock = accept(sockfd, (struct sockaddr *)&client_addr, &client_addrlen);

    if (new_sock == -1) {
        perror("accept");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    printf("Client connected from %s:%d\n", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));

    // 在此之后，可以使用 new_sock 套接字与客户端进行通信

    // 关闭新套接字
    close(new_sock);

    // 关闭监听套接字
    close(sockfd);

    return 0;
}
```

 在上述示例中，我们创建了一个IPv4的TCP套接字，将其绑定到本地地址，并使用 `listen()` 函数将套接字设置为监听状态，等待客户端连接请求。一旦连接请求到来，我们使用 `accept()` 函数接受连接，创建一个新的套接字 (`new_sock`) 用于与客户端通信。这个新套接字可以独立于原始监听套接字进行数据的发送和接收  。 

--------------



#### `recv`函数`<sys/socket.h`

`recv()` 函数是用于从套接字接收数据的系统调用，通常用于在网络编程中接收数据。它的函数原型如下：

```c
size_t recv(int sockfd, void *buf, size_t len, int flags);
```

- `sockfd`：套接字描述符，表示要接收数据的套接字。
- `buf`：一个指向接收数据缓冲区的指针，用于存储接收到的数据。
- `len`：要接收的最大数据量（以字节为单位）。
- `flags`：可选的标志参数，可以用来修改接收操作的行为。通常情况下，可以将其设置为0以使用默认行为。套接字可以设置默认是阻塞还是非阻塞行为。
  - `MSG_DONTWAIT`：设置该标志后，`recv()` 函数将以非阻塞方式运行，即如果没有可用数据，它将立即返回，而不会等待数据的到来。如果没有数据可用，函数会返回 `-1`，并将 `errno` 设置为 `EAGAIN` 或 `EWOULDBLOCK`。
  - `MSG_PEEK`：设置该标志后，`recv()` 函数将查看套接字接收缓冲区中的数据，但不从缓冲区中移除数据。这意味着你可以多次调用 `recv()`，每次调用都会返回相同的数据，直到你决定将数据从缓冲区中移除。
  - `MSG_WAITALL`：设置该标志后，`recv()` 函数将等待接收到指定数量的字节，直到满足要求为止。如果没有足够的数据可用，它将一直等待，直到数据到来或发生错误。

返回值：

- 如果成功接收数据，返回值是接收到的字节数（非负整数），可以小于或等于 `len`。
- 如果连接被关闭，返回值为0，表示已经接收到EOF（End of File）。
- 如果发生错误，返回值为-1，表示接收失败，具体的错误信息可以通过 `errno` 获取。

`recv()` 函数通常用于阻塞模式的套接字，它会阻塞当前线程，直到有数据可用或发生错误。如果你希望非阻塞地接收数据，可以使用 `recv()` 函数的 `flags` 参数，将 `MSG_DONTWAIT` 标志设置为非零值。



#### `read`函数`unistd.h`

`read()` 函数是一个用于从文件描述符（包括套接字）中读取数据的系统调用，通常用于在文件操作和套接字编程中读取数据。

在网络编程中属于阻塞IO，套接字中有数据则读取返回，没有数据则阻塞，不一定要读满。

它的函数原型如下：

```
size_t read(int fd, void *buf, size_t count);
```

- `fd`：文件描述符，表示要从其读取数据的文件或套接字。
- `buf`：一个指向接收数据的缓冲区的指针，用于存储读取到的数据。
- `count`：要读取的最大字节数。

返回值：

- 如果成功读取数据，返回值是实际读取的字节数（非负整数），可以小于或等于 `count`。
- 如果已经到达文件的末尾（EOF），返回值为0，表示没有更多数据可读。 当连接关闭时 ，`read` 函数将返回 0，这是因为在标准的 TCP 套接字中，EOF（文件结束符）被映射为连接关闭。这是 `read` 的一种指示，告诉你已经读取到了文件的末尾或连接的末尾。 
- 如果发生错误，返回值为-1，表示读取失败，具体的错误信息可以通过 `errno` 获取。设置为非阻塞IO也是返回-1,如果是客户端异常断开连接则会也会返回-1,同时 `errno` 的值会被设置为 `ECONNRESET`（连接被对端重置）或其他与连接异常关闭相关的错误码，这取决于操作系统和网络库的具体实现 

`read()` 函数通常用于阻塞模式的文件描述符，它会阻塞当前线程，直到有足够的数据可用或发生错误。如果需要非阻塞方式读取数据，可以使用 `fcntl()` 函数或 `O_NONBLOCK` 标志来将文件描述符设置为非阻塞模式。





#### `recvfrom`函数`sys/socket.h`

`recvfrom()` 函数是用于从套接字接收数据并获取发送方的地址信息的系统调用，通常用于在UDP套接字编程中接收数据。它的函数原型如下：

```
size_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
```

- `sockfd`：套接字描述符，表示要从其接收数据的套接字。
- `buf`：一个指向接收数据缓冲区的指针，用于存储接收到的数据。
- `len`：要接收的最大字节数。
- `flags`：可选的标志参数，可以用来修改接收操作的行为，通常可以设置为0以使用默认行为。和recv一致
  - **MSG_DONTWAIT**：设置该标志后，`recvfrom()` 函数将以非阻塞方式运行，即如果没有可用数据，它将立即返回，而不会等待数据的到来。如果没有数据可用，函数会返回 `-1`，并将 `errno` 设置为 `EAGAIN` 或 `EWOULDBLOCK`。
  - **MSG_PEEK**：设置该标志后，`recvfrom()` 函数将查看套接字接收缓冲区中的数据，但不从缓冲区中移除数据。这意味着你可以多次调用 `recvfrom()`，每次调用都会返回相同的数据，直到你决定将数据从缓冲区中移除
- `src_addr`：一个指向 `struct sockaddr` 结构体的指针，用于存储发送方的地址信息。`recvfrom()` 函数会将发送方的地址信息填充到这个结构体中。
- `addrlen`：一个指向存储 `src_addr` 结构体长度的整数指针。在调用 `recvfrom()` 之前，你需要将其设置为指向 `src_addr` 结构体的实际大小，`recvfrom()` 函数会在接收时修改它以反映发送方地址的实际大小。

返回值：

- 如果成功接收数据，返回值是实际读取的字节数（非负整数），可以小于或等于 `len`。
- 如果连接被关闭，返回值为0，表示已经接收到EOF（End of File）。
- 如果发生错误，返回值为-1，表示接收失败，具体的错误信息可以通过 `errno` 获取。

`recvfrom()` 函数通常用于UDP套接字编程，因为UDP是面向数据包的协议，每个数据包都包含了发送方的地址信息。通过 `recvfrom()` 可以获取发送方的地址，以便服务器或客户端可以回复数据。

------------

#### `send`函数 `sys/socket.h`

`send()` 函数是用于通过套接字发送数据的系统调用，通常用于网络编程中向远程主机发送数据。它的函数原型如下：

```c
size_t send(int sockfd, const void *buf, size_t len, int flags);
```

- `sockfd`：套接字描述符，表示要发送数据的套接字。
- `buf`：一个指向包含要发送的数据的缓冲区的指针。
- `len`：要发送的数据的字节数。
- `flags`：可选的标志参数，可以用来修改发送操作的行为。通常情况下，可以将其设置为0以使用默认行为。 当 `flags` 参数为0时，`send()` 函数将按照默认的方式执行发送操作，这通常意味着它将等待发送缓冲区可用，然后将数据发送出去。如果发送缓冲区已满，`send()` 函数将阻塞当前线程，直到有足够的空间来发送数据。这是常规的、阻塞式的发送操作。 
  - **MSG_DONTROUTE**：通常用于 UDP 套接字，它告诉系统不要将数据路由到其他网络，而是直接发送到指定的目标地址。这可以减少路由器的处理，但需要确保目标地址是直接可达的。
  - **MSG_DONTWAIT**：设置该标志后，`send()` 函数将以非阻塞方式运行，即如果发送缓冲区已满，它将立即返回，而不会等待缓冲区可用。如果发送缓冲区已满，函数会返回 `-1`，并将 `errno` 设置为 `EAGAIN` 或 `EWOULDBLOCK`。
  - **MSG_MORE**：告诉系统后续数据还会发送，这可以用于优化多个小数据包的发送，以减少延迟。这个标志通常用于 TCP 套接字，表示数据流还没有结束。
  - **MSG_NOSIGNAL**：通常用于阻止 `send()` 函数在发送数据时产生 `SIGPIPE` 信号。如果远程主机关闭连接，而你的程序仍然试图发送数据，如果不设置此标志，可能会触发 `SIGPIPE` 信号，导致进程终止。设置此标志后，`send()` 函数会返回错误而不会生成信号。

返回值：

- 如果成功发送数据，返回值是实际发送的字节数（非负整数），通常等于 `len`。
- 如果发生错误，返回值为-1，表示发送失败，具体的错误信息可以通过 `errno` 获取。

`send()` 函数通常用于阻塞模式的套接字，它会阻塞当前线程，直到发送操作完成或发生错误。如果需要非阻塞方式发送数据，可以使用 `send()` 函数的 `flags` 参数，将 `MSG_DONTWAIT` 标志设置为非零值。

以下是一个示例用法：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>

int main() {
    int sockfd; // 套接字描述符
    const char *message = "Hello, World!"; // 要发送的消息
    ssize_t bytes_sent;

    // 创建套接字并连接到远程服务器（假设已经创建并连接）
    sockfd = socket(AF_INET, SOCK_STREAM, 0);

    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 发送数据
    bytes_sent = send(sockfd, message, strlen(message), 0);

    if (bytes_sent == -1) {
        perror("send");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    printf("Sent %zd bytes: %s\n", bytes_sent, message);

    // 关闭套接字
    close(sockfd);

    return 0;
}
```

在上述示例中，我们创建了一个套接字并使用 `send()` 函数向远程服务器发送消息。发送的消息存储在 `message` 变量中。如果发送成功，`send()` 函数返回实际发送的字节数，我们打印出发送的字节数以及发送的消息。如果发生错误，会使用 `perror()` 打印错误消息。在实际编程中，你需要根据通信协议和需求来构建要发送的数据。

--------------

####  `write` 函数`unistd.h`

`write()` 函数是用于将数据写入文件描述符（包括套接字）的系统调用，通常用于向文件或套接字写入数据。它的函数原型如下：

```c
ssize_t write(int fd, const void *buf, size_t count);
```

- `fd`：文件描述符，表示要写入数据的文件或套接字。
- `buf`：一个指向包含要写入的数据的缓冲区的指针。
- `count`：要写入的数据的字节数。

返回值：

- 如果成功写入数据，返回值是实际写入的字节数（非负整数），通常等于 `count`。
- 如果发生错误，返回值为-1，表示写入失败，具体的错误信息可以通过 `errno` 获取。

`write()` 函数通常用于阻塞模式的文件描述符，它会阻塞当前线程，直到写入操作完成或发生错误。如果需要非阻塞方式写入数据，可以使用 `fcntl()` 函数或 `O_NONBLOCK` 标志将文件描述符设置为非阻塞模式。

-----------------------

#### `sendto`函数 ` arpa/inet.h `

`sendto()` 函数是用于通过套接字向指定目标地址发送数据的系统调用，通常用于在UDP套接字编程中向远程主机发送数据。它的函数原型如下：

```
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
```

- `sockfd`：套接字描述符，表示要发送数据的套接字。
- `buf`：一个指向包含要发送的数据的缓冲区的指针。
- `len`：要发送的数据的字节数。
- `flags`：可选的标志参数，可以用来修改发送操作的行为，通常可以设置为0以使用默认行为。
- `dest_addr`：一个指向 `struct sockaddr` 结构体的指针，表示目标地址的信息。这可以是远程主机的地址和端口信息。
- `addrlen`：一个整数，表示 `dest_addr` 结构体的长度。

返回值：

- 如果成功发送数据，返回值是实际发送的字节数（非负整数），通常等于 `len`。
- 如果发生错误，返回值为-1，表示发送失败，具体的错误信息可以通过 `errno` 获取。

`sendto()` 函数通常用于UDP套接字编程，因为UDP是面向数据包的协议，可以直接指定目标地址来发送数据。这个函数允许你在每次发送时指定目标地址，因此适用于需要将数据发送到不同目标的情况。

-------------------



- 这些函数用于将数据从套接字发送到目标。函数的具体原型和参数也根据使用的函数而不同，但它们的通用目标是发送指定数量的数据。这些函数的返回值是实际发送的字节数，如果发生错误，则返回 -1。

#### `close`函数`unistd.h`

`close()` 函数是用于关闭文件描述符（包括套接字）的系统调用。它的函数原型如下：

```
int close(int sockfd);
```

- `sockfd`：文件描述符，表示要关闭的文件或套接字。

返回值：

- 如果成功关闭文件描述符，返回值为0。
- 如果发生错误，返回值为-1，表示关闭失败，具体的错误信息可以通过 `errno` 获取。

`close()` 函数通常用于关闭不再需要的文件描述符，以释放系统资源并确保文件或套接字不再使用。在网络编程中，当不再需要一个套接字时，应该使用 `close()` 函数来关闭它，以防止资源泄漏和释放网络连接。

----------------



#### `shutdown`函数`sys/socket.h`

`close()` 用于关闭套接字，释放相关资源。

`shutdown()` 用于关闭套接字的一部分功能，可以关闭发送或接收功能。

`shutdown()` 函数是用于关闭套接字的一个系统调用，它允许你在不同的方式下关闭套接字的读取和写入操作。它的函数原型如下：

```c
int shutdown(int sockfd, int howto);
```

- `sockfd`：套接字描述符，表示要关闭的套接字。
- `howto`：表示关闭套接字的方式，可以取以下值之一：
  - `SHUT_RD`（0）：关闭套接字的读取操作。这意味着你不能再从套接字中读取数据，但仍然可以进行写入操作。
  - `SHUT_WR`（1）：关闭套接字的写入操作。这意味着你不能再向套接字写入数据，但仍然可以进行读取操作。
  - `SHUT_RDWR`（2）：同时关闭套接字的读取和写入操作，等效于分别调用 `shutdown()` 来关闭读取和写入操作。

返回值：

- 如果成功关闭套接字，返回值为0。
- 如果发生错误，返回值为-1，表示关闭失败，具体的错误信息可以通过 `errno` 获取。

`shutdown()` 函数通常用于网络编程中，在不需要继续进行某种类型的数据传输时，可以选择性地关闭套接字的读取或写入操作，从而实现半关闭连接或清理资源。通常情况下，关闭套接字的同时会发送一个TCP FIN（Finish）包通知对方连接将关闭。

----------------

#### `setsockopt` 函数`sys/socket.h`

`setsockopt` 函数用于设置套接字选项的值，允许您配置套接字的行为和属性。以下是 `setsockopt` 函数的详细信息：

```
int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);
```

- `sockfd`：套接字描述符，表示要操作的套接字。

- `level`：选项的级别，通常是 `SOL_SOCKET`（通用套接字选项）或其他协议特定级别。

  - `SOL_SOCKET`（通用套接字选项）：
    - 这个级别用于通用的套接字选项，适用于多种协议。
    - 常见选项包括 `SO_REUSEADDR`、`SO_REUSEPORT`、`SO_KEEPALIVE` 等。
  - `IPPROTO_TCP`（TCP 协议选项）：
    - 这个级别用于设置和获取 TCP 协议相关的选项。
    - 常见选项包括 `TCP_NODELAY`（禁用 Nagle 算法）等。
  - `IPPROTO_IP`（IP 协议选项）：
    - 这个级别用于设置和获取 IP 协议相关的选项。
    - 常见选项包括 `IP_TOS`（服务类型）、`IP_TTL`（生存时间）等。
  - `IPPROTO_IPV6`（IPv6 协议选项）：
    - 这个级别用于设置和获取 IPv6 协议相关的选项。
    - 常见选项包括 `IPV6_V6ONLY`（限制只使用 IPv6）等。
  - `SOL_UDP`（UDP 协议选项）：
    - 这个级别用于设置和获取 UDP 协议相关的选项。
    - 常见选项包括 `UDP_CORK`（启用或禁用 Corking）等。
  - `SOL_RAW`（原始套接字选项）：
    - 这个级别用于设置和获取原始套接字相关的选项。

- `optname`：要设置的选项的名称，例如 `SO_REUSEADDR`。

  ```
  选项名称　　　　　　　　  说明　　　　　　　　　　　　　　　　　　数据类型 
  
  ========================================================================== 
   　　　　　　　　　　　   SOL_SOCKET 
   -----------------------------------------------------------------------
   SO_BROADCAST　　　　　　允许发送广播数据　　　　　　　　　　　　int 
   SO_DEBUG　　　　　　　　允许调试　　　　　　　　　　　　　　　　int 
   SO_DONTROUTE　　　　　　不查找路由　　　　　　　　　　　　　　　int 
   SO_ERROR　　　　　　　　获得套接字错误　　　　　　　　　　　　　int 
   SO_KEEPALIVE　　　　　　保持连接　　　　　　　　　　　　　　　　int 
   SO_LINGER　　　　　　　 延迟关闭连接　　　　　　　　　　　　　　struct linger 
   SO_OOBINLINE　　　　　　带外数据放入正常数据流　　　　　　　　　int 
   SO_RCVBUF　　　　　　　 接收缓冲区大小　　　　　　　　　　　　　int 
   SO_SNDBUF　　　　　　　 发送缓冲区大小　　　　　　　　　　　　　int 
   SO_RCVLOWAT　　　　　　 接收缓冲区下限　　　　　　　　　　　　　int 
   SO_SNDLOWAT　　　　　　 发送缓冲区下限　　　　　　　　　　　　　int 
   SO_RCVTIMEO　　　　　　 接收超时　　　　　　　　　　　　　　　　struct timeval 
   SO_SNDTIMEO　　　　　　 发送超时　　　　　　　　　　　　　　　　struct timeval 
   SO_REUSERADDR　　　　　 允许重用本地地址和端口　　　　　　　　　int 
   SO_TYPE　　　　　　　　 获得套接字类型　　　　　　　　　　　　　int 
   SO_BSDCOMPAT　　　　　　与BSD系统兼容　　　　　　　　　　　　　 int 
  
  
  ==========================================================================       　　　　　　　　　　　   IPPROTO_IP 
  --------------------------------------------------------------------------
  
   IP_HDRINCL　　　　　　 在数据包中包含IP首部　　　　　　　　　　int 
   IP_OPTINOS　　　　　　 IP首部选项　　　　　　　　　　　　　　　int 
   IP_TOS　　　　　　　　  服务类型 
   IP_TTL　　　　　　　　　生存时间　　　　　　　　　　　　　　　　int 
  
  
  ==========================================================================
                         IPPRO_TCP 
  --------------------------------------------------------------------------
   TCP_MAXSEG　　　　　　　TCP最大数据段的大小　　　　　　　　　　 int 
   TCP_NODELAY　　　　　　 不使用Nagle算法　　　　　　　　　　　　 int 
  ```

  

- `optval`：指向包含新选项值的缓冲区的指针。

- `optlen`：`optval` 缓冲区的大小。

示例用法：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 设置 SO_REUSEADDR 选项，允许地址重用==>通常在关闭服务端后没法立即重启,需要启用这个
    int optval = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {
        perror("setsockopt");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    // 其他套接字操作...
    
    close(sockfd);
    return 0;
}
```

在这个示例中，`setsockopt` 用于启用 `SO_REUSEADDR` 选项，允许地址重用。这是一个常见的套接字选项，它允许在套接字关闭后立即重新绑定相同的地址，而无需等待一段时间。

#### `getsockopt` 函数`sys/socket.h`

`getsockopt` 函数用于获取套接字选项的当前值，允许您查询套接字的属性和配置。以下是 `getsockopt` 函数的详细信息：

```
int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);
```

- `sockfd`：套接字描述符，表示要查询的套接字。
- `level`：选项的级别，通常是 `SOL_SOCKET`（通用套接字选项）或其他协议特定级别。
- `optname`：要获取的选项的名称，例如 `SO_REUSEADDR`。
- `optval`：指向用于存储选项值的缓冲区的指针。
- `optlen`：指向 `optval` 缓冲区大小的指针，同时也用于存储选项值的大小。

示例用法：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 查询 SO_REUSEADDR 选项的当前值
    int optval;
    socklen_t optlen = sizeof(optval);
    if (getsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &optval, &optlen) == -1) {
        perror("getsockopt");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    if (optval) {
        printf("SO_REUSEADDR is enabled.\n");
    } else {
        printf("SO_REUSEADDR is disabled.\n");
    }

    // 其他套接字操作...

    close(sockfd);
    return 0;
}
```





-------------

## TCP编程例子

tcp编程需要客户端与服务器建立连接后才能通信

服务器端:socket-->bind--->listen-->accept-->读写-->关闭

客户端:socket--->connect-->读写-->关闭

由于tcp需要建立连接后才能进行通信,读写的时候不需要再指定对方ip,读写函数是read/recv,write/send

### 服务端

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

int main() {
    int sockfd, new_sockfd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    char buffer[1024];
    const char *message = "Hello from server!";
    
    // 创建TCP套接字
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    //-------可重用,接收,发送超时,要想用默认超时只能用recv,send
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {
        perror("setsockopt");
        close(sockfd);
        exit(EXIT_FAILURE);
    }
    
    struct timeval  tv;
    tv.tv_sec = 5;   //  设置5秒时间
    tv.tv_usec = 0;
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO,  &tv, sizeof(tv))){
        perror("setsockopt");
        close(sockfd);
        exit(EXIT_FAILURE);
    }   //  设置接收超时,发送超时同理
    
    //-----------
    
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080); // 设置监听端口
    server_addr.sin_addr.s_addr = INADDR_ANY; // 监听所有可用的网络接口
    
    // 绑定套接字到地址和端口
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("bind");
        close(sockfd);
        exit(EXIT_FAILURE);
    }
    
    /*
    *可以改为==>多线程或者多进程的机制,或者使用io多路复用,使得一个服务端处理多个客户端
    */
    
    // 监听端口，等待连接请求
    if (listen(sockfd, 5) == -1) {
        perror("listen");
        close(sockfd);
        exit(EXIT_FAILURE);
    }
    
    printf("Server is listening on port 8080...\n");
    
    // 接受客户端连接请求
    new_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &client_addr_len);
    
    if (new_sockfd == -1) {
        perror("accept");
        close(sockfd);
        exit(EXIT_FAILURE);
    }
    
    // 从客户端接收数据
    ssize_t bytes_received = recv(new_sockfd, buffer, sizeof(buffer), 0);
    
    if (bytes_received == -1) {
        perror("recv");
        close(new_sockfd);
        close(sockfd);
        exit(EXIT_FAILURE);
    }
    
    buffer[bytes_received] = '\0';
    printf("Received data from client: %s\n", buffer);
    
    // 向客户端发送消息
    ssize_t bytes_sent = send(new_sockfd, message, strlen(message), 0);
    
    if (bytes_sent == -1) {
        perror("send");
    } else {
        printf("Sent data to client: %s\n", message);
    }
    
    // 关闭套接字
    close(new_sockfd);
    close(sockfd);
    
    return 0;
}
```



### 客户端

客户端并没有显式指定本地端口。TCP客户端通常不需要显式指定本地端口，因为操作系统会自动分配一个可用的本地端口。

当客户端调用 `socket()` 创建套接字时，操作系统会为该套接字分配一个本地端口。这个本地端口通常是临时分配的，并且不需要你手动指定。然后，当客户端调用 `connect()` 连接到服务器时，操作系统会使用分配的本地端口与服务器的IP地址和端口建立连接。

特殊情况下可以自己使用bind去绑定端口

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

int main() {
    int sockfd;
    struct sockaddr_in server_addr;
    char buffer[1024];
    
    // 创建TCP套接字
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080); // 连接到服务端的端口
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1"); // 连接到服务端的IP地址
    
    // 连接到服务器
    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("connect");
        close(sockfd);
        exit(EXIT_FAILURE);
    }
    
    // 向服务器发送数据
    const char *message = "Hello from client!";
    ssize_t bytes_sent = send(sockfd, message, strlen(message), 0);
    
    if (bytes_sent == -1) {
        perror("send");
    } else {
        printf("Sent data to server: %s\n", message);
    }
    
    // 接收服务器的响应
    ssize_t bytes_received = recv(sockfd, buffer, sizeof(buffer), 0);
    
    if (bytes_received == -1) {
        perror("recv");
    } else {
        buffer[bytes_received] = '\0';
        printf("Received data from server: %s\n", buffer);
    }
    
    // 关闭套接字
    close(sockfd);
    
    return 0;
}
```



## UDP编程例子

UDP不需要建立连接和绑定端口,一个进程既可以是服务器端也可以是客户端,发送和接收都要指定ip和端口

### 服务端

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

int main() {
    int sockfd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    char buffer[1024];
    const char *message = "Hello from server!";
    
    // 创建UDP套接字
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080); // 设置监听端口
    server_addr.sin_addr.s_addr = INADDR_ANY; // 监听所有可用的网络接口
    
    // 绑定套接字到地址和端口
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("bind");
        close(sockfd);
        exit(EXIT_FAILURE);
    }
    
    printf("Server is listening on port 8080...\n");
    
    // 接收客户端发送的数据
    ssize_t bytes_received = recvfrom(sockfd, buffer, sizeof(buffer), 0, (struct sockaddr *)&client_addr, &client_addr_len);
    
    if (bytes_received == -1) {
        perror("recvfrom");
        close(sockfd);
        exit(EXIT_FAILURE);
    }
    
    buffer[bytes_received] = '\0';
    printf("Received data from client: %s\n", buffer);
    
    // 向客户端发送响应消息
    ssize_t bytes_sent = sendto(sockfd, message, strlen(message), 0, (struct sockaddr *)&client_addr, client_addr_len);
    
    if (bytes_sent == -1) {
        perror("sendto");
    } else {
        printf("Sent data to client: %s\n", message);
    }
    
    // 关闭套接字
    close(sockfd);
    
    return 0;
}
```

### 客户端

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

int main() {
    int sockfd;
    struct sockaddr_in server_addr;
    char buffer[1024];
    
    // 创建UDP套接字
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080); // 服务器端口号
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1"); // 服务器IP地址
    
    // 向服务器发送数据
    const char *message = "Hello from client!";
    ssize_t bytes_sent = sendto(sockfd, message, strlen(message), 0, (struct sockaddr *)&server_addr, sizeof(server_addr));
    
    if (bytes_sent == -1) {
        perror("sendto");
        close(sockfd);
        exit(EXIT_FAILURE);
    }
    
    // 接收服务器的响应
    ssize_t bytes_received = recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, NULL);
    
    if (bytes_received == -1) {
        perror("recvfrom");
    } else {
        buffer[bytes_received] = '\0';
        printf("Received data from server: %s\n", buffer);
    }
    
    // 关闭套接字
    close(sockfd);
    
    return 0;
}
```



## IO模型

1. **阻塞IO（Blocking IO）**：==>默认几乎都是阻塞IO
   - 在阻塞IO模型中，应用程序会调用一个IO操作（如读取或写入），然后等待直到操作完成。
   - 如果没有数据可读或写入缓冲区已满，进程将被阻塞，直到数据准备好或者缓冲区有足够的空间。UDP写几乎不会阻塞
   - 这种模型通常易于使用，但在等待IO完成时，应用程序的其他任务会被阻塞，可能导致资源浪费。
2. **非阻塞IO（Non-blocking IO）**：
   - 在非阻塞IO模型中，应用程序可以通过将套接字设置为非阻塞模式来执行IO操作，这样它不会阻塞进程。
   - 当没有数据可读取时，读操作会立即返回，而不是阻塞等待。
   - 非阻塞IO通常需要使用轮询来检查IO是否准备好，这可能导致CPU资源的浪费。
3. **多路复用IO（Multiplexing IO）**：(常用)
   - 多路复用IO使用系统调用如 `select`、`poll` 或 `epoll` 来同时监视多个套接字的IO状态。
   - 当其中一个套接字可以执行IO操作时，应用程序将得到通知，并可以执行相应的IO操作。
   - 这种模型避免了阻塞和轮询，允许一个进程管理多个套接字，提高了IO效率。
4. **信号驱动IO（Signal-driven IO）**：
   - 信号驱动IO允许应用程序注册一个信号处理函数，当IO操作完成时，内核将发送一个信号来通知应用程序。
   - 这种模型通常用于套接字上的读操作，可以避免阻塞。
   - 但信号驱动IO模型对于某些情况可能不够高效，并且需要处理信号的异步性。



### 非阻塞IO api

#### `fcntl`函数`fcntl.h`

`fcntl()` 函数是用于在Unix/Linux系统中进行文件控制操作的函数，它可以用于对文件描述符（包括套接字）执行各种操作，如设置文件属性、锁定文件、获取文件状态等。`fcntl()` 函数通常用于实现高级IO和进程间通信等功能。

`fcntl()` 函数的基本原型如下：

```
#include <fcntl.h>

int fcntl(int fd, int cmd, ... /* arg */);
```

- `fd` 是要进行操作的文件描述符。

- ```
  cmd
  ```

   是指定要执行的操作的命令，可以是以下之一：

  - `F_DUPFD`：复制文件描述符。
  - `F_GETFD`：获取文件描述符标志。
  - `F_SETFD`：设置文件描述符标志。
  - `F_GETFL`：获取文件状态标志。
  - `F_SETFL`：设置文件状态标志。
  - `F_GETLK`：获取文件锁状态。
  - `F_SETLK`：设置文件锁。
  - `F_SETLKW`：设置文件锁并等待锁可用。

- `arg` 是与指定命令相关的参数，具体类型和含义取决于命令。

实现非阻塞IO

```c
      int flag；
      flag = fcntl(sockfd, F_GETFL, 0); // 文件描述符
      flag |= O_NONBLOCK;
      fcntl(sockfd, F_SETFL, flag);
```

#### `ioctl`函数`sys/ioctl.h`

`ioctl()` 是一个用于执行设备特定控制操作的系统调用，通常用于与设备驱动程序交互、配置设备参数以及进行其他与设备相关的操作。`ioctl()` 的名称代表 "I/O 控制"。

`ioctl()` 函数的基本原型如下：

```
#include <sys/ioctl.h>

int ioctl(int fd, unsigned long request, ...);
```

- `fd` 是文件描述符，通常是与设备相关的文件描述符，如打开的设备文件或套接字。
- `request` 是一个无符号长整数，指定要执行的特定控制操作。这个参数通常是一个预定义的宏，以确定要执行的操作，例如设置设备参数、查询设备状态等。
- 可选的参数 `...` 取决于 `request` 的操作，有些操作需要提供额外的参数，而其他操作不需要。

实现非阻塞

```c
   int b_on =1;
   ioctl(sock_fd, FIONBIO, &b_on);
```



### 多路IO复用 api

无论是进程,线程用来单独处理某个连接,切换的开销相对来说还是大了,多路io复用可以解决这个问题

#### `select`函数` sys/select.h `

 `select` 是一个用于多路复用（Multiplexing）的系统调用，通常用于监视多个文件描述符的状态，以确定它们中是否有可读、可写或异常事件发生。它允许程序在一个调用中等待多个文件描述符的事件，而不必使用多线程或多进程。 

```c
#include <sys/select.h>

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

- `nfds` 表示要监视的文件描述符的数量，通常设置为待监视的最大文件描述符值加1。

- `readfds`、`writefds` 和 `exceptfds` 是分别用于指定要监视可读、可写和异常事件的文件描述符集合。这些集合通常通过 `FD_ZERO` 和 `FD_SET` 等宏来初始化和操作,不需要监控的可以设置为NULL。

- `timeout` 是一个指定超时时间的结构体，用于设置 `select` 调用的超时限制。如果设置为 `NULL`，`select` 将一直阻塞，直到有事件发生；如果设置为一个指定时间间隔，`select` 将在指定的时间内返回。

  ```C
  struct timeval {
      long tv_sec;  // 秒数
      long tv_usec; // 微秒数（百万分之一秒）
  };
  // 设置该结构体时,不用的字段需要设置为0
  ```

  

`select` 的返回值是就绪文件描述符的数量，如果在超时时间内没有就绪的文件描述符，返回值为0。如果发生错误，返回值为-1，并设置 `errno` 来指示错误类型。

select需要配合fd_set使用==>fd_set是一个1024bit的位域,每一位代表一个文件描述符,我们可以通过指定的宏将需要被监控的文件描述符在fd_set中进行设置,select将监控sf_set中文件描述符,一旦有状态发生改变或者超时,select将退出阻塞状态,退出阻塞后的sf_set将被重置,只保留有状态发生改变的文件,要重新监控则需要清空,重新设置文件描述符。

所以在使用 `select` 等函数之前，需要创建并初始化一个 `fd_set` 数据结构，并使用 `FD_SET` 将要监视的文件描述符添加到集合中。然后，`select` 调用将检查这些文件描述符的状态，并在就绪时返回。 

`fd_set` 是一个用于表示文件描述符集合的数据结构，通常用于多路复用函数如 `select`、`poll` 和 `epoll` 中。它是一个位掩码，每个位代表一个文件描述符的状态（是否就绪）。

`fd_set` 的定义通常在  sys/select.h 头文件中，但它的底层实现可能因操作系统而异。以下是 `fd_set` 的基本操作宏：

- `FD_ZERO(fdset)`：将 `fdset` 中的所有位清零，表示没有文件描述符被设置。
- `FD_SET(fd, fdset)`：将指定的文件描述符 `fd` 设置到 `fdset` 中，表示关注该文件描述符的状态。
- `FD_CLR(fd, fdset)`：将指定的文件描述符 `fd` 从 `fdset` 中清除，表示不再关注该文件描述符的状态。
- `FD_ISSET(fd, fdset)`：检查指定的文件描述符 `fd` 是否在 `fdset` 中被设置，表示它的状态已经就绪。

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/select.h>
#include <sys/types.h>
#include <unistd.h>

int main() {
    fd_set readfds; //用于存放要监控的文件描述符,1024bit的结构体
    struct timeval timeout;
    int result;

    // 清空并设置要监视的文件描述符集合
    FD_ZERO(&readfds);
    //-----------通常是放入多个 然后循环使用select
    // 放入需要监控的描述符符号==>可以使用循环放入多个
    FD_SET(STDIN_FILENO, &readfds); // 监视标准输入

    // 设置超时时间为5秒
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;

    // 使用 select 监视可读事件
    result = select(STDIN_FILENO + 1, &readfds, NULL, NULL, &timeout);

    if (result == -1) {
        perror("select");
    } else if (result == 0) {
        printf("No data within 5 seconds.\n");
    } else {
        if (FD_ISSET(STDIN_FILENO, &readfds)) {
            printf("Data is available to read from standard input.\n");
        }
    }

    return 0;
}
```

####  `pselect `函数` sys/select.h `

`pselect` 是与 `select` 类似的系统调用，用于监视多个文件描述符的状态，以确定它们中是否有可读、可写或异常事件发生。但 `pselect` 在某些方面更加灵活，并且通常用于实现更复杂的多路复用操作。可以用来暂时忽略特定信号，

`pselect` 的基本原型如下：

```
#include <sys/select.h>

int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask);
```

与 `select` 相比，`pselect` 具有以下不同之处：

1. **timeout 参数的类型变更**：`pselect` 使用了 `struct timespec` 结构体来表示超时时间，而不再使用 `struct timeval`。这使得你可以更精确地指定等待时间，包括纳秒级别的精度。

   ```
   struct timespec {
       time_t tv_sec;      // 秒数
       long   tv_nsec;     // 纳秒数（10^(-9) 秒）
   };
   ```

   

2. **sigmask 参数**：`pselect` 允许你指定一个信号掩码 `sigmask`，以阻塞或不阻塞特定的信号。这可以用于更精确地控制信号处理。

`sigmask` 参数是一个指向信号集的指针，用于在 `pselect` 调用期间控制信号的阻塞状态。具体来说，`sigmask` 参数用于指定哪些信号在 `pselect` 调用期间应该被阻塞，以便不会打断 `pselect` 调用。

在 `pselect` 调用期间，如果一个信号被设置为阻塞，那么当该信号到达时，它不会被立即处理。相反，信号将被排队等待，直到 `pselect` 调用完成后，才会处理被阻塞的信号。这可以用于确保 `pselect` 调用不会被信号中断，从而提供更可靠的多路复用操作。

以下是一些示例用法和解释：

1. **将特定信号阻塞**：

   ```
   #include <signal.h>
   
   sigset_t sigmask;
   sigemptyset(&sigmask);
   sigaddset(&sigmask, SIGINT); // 阻塞 SIGINT 信号
   sigaddset(&sigmask, SIGTERM); // 阻塞 SIGTERM 信号
   int result = pselect(max_fd + 1, &readfds, NULL, NULL, &timeout, &sigmask);
   ```

   在这个示例中，`SIGINT` 和 `SIGTERM` 信号被阻塞，以确保它们在 `pselect` 调用期间不会被处理。

2. **阻塞任何信号**：

   ```
   sigset_t sigmask;
   sigfillset(&sigmask); // 阻塞所有信号
   int result = pselect(max_fd + 1, &readfds, NULL, NULL, &timeout, &sigmask);
   ```

   在这个示例中，`sigmask` 中包含了所有信号，因此在 `pselect` 调用期间所有信号都会被阻塞，确保不会中断 `pselect` 操作。



#### `poll`函数 `poll.h`

select每次都要重复去设置fd_set,浪费了时间,同时fd_set固定大小为1024bit,每次都会将fd_set拷贝到内核空间,让内核处理.

poll解决了固定大小1024问题，poll修改了fd_set的定义，fd_set不再是位域，而是一个结构体数组，但是依旧有用户到内核的拷贝开销，同时在处理是否有事件发生的时候会完整遍历整个fd_set

```
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

- `fds` 是一个指向 `struct pollfd` 结构体数组的指针，用于描述要监视的文件描述符和关注的事件。
- `nfds` 表示要监视的文件描述符的数量。
- `timeout` 用于设置 `poll` 调用的超时限制，以毫秒为单位。如果设置为负值，`poll` 将一直阻塞，直到有事件发生。如果设置为0，`poll` 将立即返回，用于查询是否有事件就绪。如果设置为正值，`poll` 将等待指定的毫秒数后返回。

`struct pollfd` 结构体用于描述每个文件描述符的状态和关注事件，其定义如下：

```
struct pollfd {
    int   fd;         // 文件描述符
    short events;     // 要监视的事件（可读、可写、异常等）
    short revents;    // 实际发生的事件
};
```

- `fd` 表示要监视的文件描述符。
- `events` 表示要关注的事件，可以使用 `POLLIN` 表示可读事件、`POLLOUT` 表示可写事件等。可以使用|表示多个事件
  - **POLLIN**：表示关注可读事件，即文件描述符上有数据可读。
  - **POLLPRI**：表示关注高优先级可读事件，通常用于处理带外（Out-of-Band）数据。
  - **POLLOUT**：表示关注可写事件，即文件描述符可以写入数据。
  - **POLLRDHUP**：表示关注套接字的对端关闭连接。
  - **POLLERR**：表示关注错误事件，即发生错误。
  - **POLLHUP**：表示关注挂起事件，即文件描述符被挂起。
  - **POLLNVAL**：表示关注无效事件，即文件描述符未打开或不支持所请求的操作。
- `revents` 表示实际发生的事件，`poll` 调用返回后，该字段将包含已就绪的事件。

```c
#include <stdio.h>
#include <stdlib.h>
#include <poll.h>

int main() {
    struct pollfd fds[2];
    int timeout = 5000; // 超时时间为5秒

    // 设置要监视的文件描述符和关注的事件
    fds[0].fd = STDIN_FILENO; // 监视标准输入
    fds[0].events = POLLIN;  // 关注可读事件

    fds[1].fd = sockfd;      // 监视套接字
    fds[1].events = POLLIN;  // 关注可读事件

    // 使用 poll 监视文件描述符
    int result = poll(fds, 2, timeout);

    if (result == -1) {
        perror("poll");
    } else if (result == 0) {
        printf("No data within 5 seconds.\n");
    } else {
        // 检查哪些文件描述符已就绪
        if (fds[0].revents & POLLIN) {
            printf("Data is available to read from standard input.\n");
        }
        if (fds[1].revents & POLLIN) {
            // 处理套接字的可读事件
        }
    }

    return 0;
}
```



#### `epoll_create` 函数 `sys/epoll.h`



`epoll_create` 函数用于创建一个 `epoll` 实例，返回一个文件描述符，该描述符用于后续的 `epoll` 操作。以下是 `epoll_create` 函数的原型和用法：

```
#include <sys/epoll.h>

int epoll_create(int size);
```

- `size` 参数表示期望监视的文件描述符数量的提示，但实际上这个参数在新版本的 Linux 内核中已经不再使用，可以将其设置为任何非负值。

`epoll_create` 函数将创建一个新的 `epoll` 实例，类似于初始化 `epoll`。这个实例将用于后续的 `epoll` 操作，如添加、修改、删除监视的文件描述符和等待事件就绪。

 如果成功，返回poll 专用的文件描述符，否者失败，返回-1。 





#### `epoll_ctl` 函数 `sys/epoll.h`

`epoll_ctl` 函数用于向 `epoll` 实例中添加、修改或删除要监视的文件描述符和关注的事件。它允许你动态地管理需要监视的文件描述符。以下是 `epoll_ctl` 函数的原型和用法：

```
#include <sys/epoll.h>

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```

- `epfd` 是 `epoll` 实例的文件描述符，即你之前通过 `epoll_create` 创建的描述符。
- op表示操作类型，可以取以下值之一：
  - `EPOLL_CTL_ADD`：添加一个新的文件描述符到 `epoll` 实例中。
  - `EPOLL_CTL_MOD`：修改一个已存在的文件描述符的关注事件。
  - `EPOLL_CTL_DEL`：从 `epoll` 实例中删除一个文件描述符。
- `fd` 是要操作的文件描述符，可以是套接字、文件或其他类型的文件描述符。
- `event` 是一个指向 `struct epoll_event` 结构体的指针，用于描述要添加或修改的文件描述符的事件和数据。

`struct epoll_event` 结构体用于描述文件描述符的事件和数据，其定义如下：

```
struct epoll_event {
    uint32_t events; // 关注的事件（位掩码）
    epoll_data_t data; // 用户定义的数据==>不常用
};
```

- `events` 字段用于设置关注的事件，可以使用位掩码来指定多个事件。常见的事件包括 `EPOLLIN`（可读事件）、`EPOLLOUT`（可写事件）、`EPOLLERR`（错误事件）等。多个事件可以用 | 连接
  - **`EPOLLIN`**：表示关注可读事件，即文件描述符上有数据可读。
  - **`EPOLLOUT`**：表示关注可写事件，即文件描述符可以写入数据。
  - **`EPOLLRDHUP`**：表示关注套接字的对端关闭连接事件。
  - **`EPOLLERR`**：表示关注错误事件，即发生错误。
  - **`EPOLLHUP`**：表示关注挂起事件，即文件描述符被挂起。
  - **`EPOLLET`**：表示启用边缘触发模式（Edge Triggered），这会导致只在文件描述符状态发生变化时才触发事件。
- `data` 字段可以用于关联用户自定义的数据，例如，可以将文件描述符与某个特定的上下文或数据结构关联起来。

 **返回值：**0表示成功，-1表示失败。 

#### `epoll_wait`函数 `sys/epoll.h`

`epoll_wait` 函数用于等待 `epoll` 实例中的文件描述符上的事件就绪。它是 `epoll` 多路复用机制的核心之一，允许你异步等待文件描述符上的事件，并在事件发生时进行处理。以下是 `epoll_wait` 函数的原型和用法：

```
#include <sys/epoll.h>

int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```

- `epfd` 是 `epoll` 实例的文件描述符，即你之前通过 `epoll_create` 创建的描述符。
- `events` 是一个指向 `struct epoll_event` 结构体数组的指针，用于存储就绪的文件描述符和事件。
- `maxevents` 表示 `events` 数组的大小，即最多可以存储多少个就绪事件。
- timeout 用于设置 epoll_wait的超时限制，以毫秒为单位。可以设置以下值之一：
  - `-1`：永久阻塞，直到有事件就绪才返回。
  - `0`：立即返回，用于查询是否有事件就绪。
  - 大于 `0`：等待指定的毫秒数后返回。

`epoll_wait` 函数会阻塞程序，直到以下条件之一满足：

- 有一个或多个文件描述符上的事件就绪。
- 超过指定的超时时间。

### 多路IO复用`select`例子

在读事件中,如果还有数据,select会继续通知可读,不用buff不够担心数据丢失问题

在tcp中,通常是客户端发送数据,服务器对数据作出响应,通常只处理读请求。

select能够检测客户端正常关闭(当做可读来处理),不具备检测客户端异常的情况,如果一个客户端异常关闭,select没法发到,需要提供额外的机制

比如read函数返回为0表示关闭

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <errno.h>

#define MAX_CLIENTS 5
#define PORT 8080

int main()
{
    int clientCount = 0; // 客户端数量
    int server_socket, new_socket, max_socket, activity, valread;
    int client_sockets[MAX_CLIENTS] = {0};
    fd_set readfds;
    char buffer[1024];
    struct sockaddr_in server_addr;

    // 创建服务器套接字
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1)
    {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 准备服务器地址结构
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    // 绑定地址和端口
    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1)
    {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    // 监听连接请求
    if (listen(server_socket, 5) == -1)
    {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    printf("Server is listening on port %d...\n", PORT);
    struct timeval timeout;
    timeout.tv_sec = 5; // 设置超时时间为1秒
    timeout.tv_usec = 0;

    while (1)
    {
        FD_ZERO(&readfds);
        FD_SET(server_socket, &readfds);
        max_socket = server_socket;
        timeout.tv_sec = 5; // 设置超时时间为1秒
        timeout.tv_usec = 0;

        for (int i = 0; i < MAX_CLIENTS; i++)
        {
            if (client_sockets[i] > 0)
            {
                FD_SET(client_sockets[i], &readfds);
                if (client_sockets[i] > max_socket)
                {
                    max_socket = client_sockets[i];
                }
            }
        }

        // 使用 select 监听套接字的可读事件
        activity = select(max_socket + 1, &readfds, NULL, NULL, &timeout);
        if ((activity < 0) && (errno != EINTR))
        {
            perror("select");
        }
        printf("进行了一次select!连接数量:%d,activity:%d\n", clientCount, activity);
        if (activity == 0)
        {
            printf("超时\n");
            // 超时，可以执行一些检查操作
            // 如果所有的客户端没有正常关闭而是异常关闭,read返回值将是-1,而不是0,没法即时关闭文件描述符
            // 需要通过一种机制去检测是否断开链接==>可以是在超时的时候检测一遍,但是依旧不保险
            // 还可以通过定时器去整体检查一遍
        }

        if (FD_ISSET(server_socket, &readfds))
        {

            // 有新的连接请求
            if ((new_socket = accept(server_socket, NULL, NULL)) < 0)
            {
                exit(EXIT_FAILURE);
                perror("accept");
            }
            if (clientCount >= MAX_CLIENTS)
            {
                write(new_socket, "服务器正忙!稍后重连!\n", sizeof("服务器正忙!稍后重连!"));
                close(new_socket);
                printf("有新连接!当前连接数量已经满,已经拒绝:%d \n", new_socket);
            }
            else
            {

                clientCount++;
                printf("New connection, socket fd is %d\n", new_socket);

                // 添加新的客户端套接字到数组
                for (int i = 0; i < MAX_CLIENTS; i++)
                {
                    if (client_sockets[i] == 0)
                    {
                        client_sockets[i] = new_socket;
                        break;
                    }
                }
            }
        }

        for (int i = 0; i < MAX_CLIENTS; i++)
        {
            if (FD_ISSET(client_sockets[i], &readfds))
            {
                // 有数据可读==>socket中=0表示断开连接,同时这里的read是阻塞式的,最好设置为非阻塞
                if ((valread = read(client_sockets[i], buffer, sizeof(buffer))) == 0)
                {
                    // 客户端断开连接
                    printf("客户端:%d断开连接\n", client_sockets[i]);
                    clientCount--;
                    close(client_sockets[i]);
                    client_sockets[i] = 0;
                }
                else
                {
                    // 处理客户端的数据
                    buffer[valread] = '\0';
                    printf("Received data from client %d: %s", client_sockets[i], buffer);
                }
            }
        }
    }
    return 0;
}
```

---------------

### 多路IO复用`poll`例子

使用poll使得下面的服务器端程序能最多允许连接5个客户端

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <poll.h>
#include <errno.h>

#define MAX_CLIENTS 5
#define PORT 8080

int main()
{
    int server_socket, new_socket;
    struct sockaddr_in server_address, client_address;
    socklen_t client_address_length = sizeof(client_address);
    struct pollfd fds[MAX_CLIENTS + 1]; // +1 for the server_socket
    char buffer[1024];
    int clientCount = 0;

    // Create server socket
    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // Set server address information
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(PORT);

    // Bind the socket to the specified address and port
    if (bind(server_socket, (struct sockaddr *)&server_address, sizeof(server_address)) == -1)
    {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    // Start listening for incoming connections
    if (listen(server_socket, 5) == -1)
    {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port %d...\n", PORT);

    // Initialize the pollfd structure for the server socket
    fds[0].fd = server_socket;
    fds[0].events = POLLIN;
    clientCount++;

    for (int i = 1; i <= MAX_CLIENTS; i++)
    {
        fds[i].fd = -1; // Initialize client sockets as unused
    }

    while (1)
    {
        int activity = poll(fds, clientCount + 1, -1);

        if (activity == -1)
        {
            perror("poll");
            exit(EXIT_FAILURE);
        }

        if (fds[0].revents & POLLIN)
        {
            // New client connection
            if ((new_socket = accept(server_socket, (struct sockaddr *)&client_address, &client_address_length)) == -1)
            {
                perror("accept");
                exit(EXIT_FAILURE);
            }

            if (clientCount >= MAX_CLIENTS + 1)
            {
                printf("Too many clients. Connection rejected.\n");
                write(new_socket, "Server is busy. Try again later.\n", sizeof("Server is busy. Try again later.\n"));
                close(new_socket);
            }
            else
            {

                for (int i = 1; i < MAX_CLIENTS + 1; i++)
                {
                    if (fds[i].fd == -1)
                    {
                        fds[i].fd = new_socket;
                        fds[i].events = POLLIN;
                        clientCount++;
                        printf("New connection, socket fd is %d\n", new_socket);
                        break;
                    }
                }
            }
        }

        for (int i = 1; i <= MAX_CLIENTS; i++)
        {
            if (fds[i].fd != -1 && (fds[i].revents & POLLIN))
            {
                // Client data available for reading
                int valread = read(fds[i].fd, buffer, sizeof(buffer));
                if (valread <= 0)
                {
                    // Client disconnected
                    printf("Client %d disconnected\n", fds[i].fd);
                    close(fds[i].fd);
                    fds[i].fd = -1;
                    clientCount--;
                }
                else
                {
                    // Process client data
                    buffer[valread] = '\0';
                    printf("Received data from client %d: %s", fds[i].fd, buffer);
                }
            }
        }
    }

    // Close the server socket
    close(server_socket);

    return 0;
}
```



-------------------

### 多路IO复用`epoll`例子

epoll内部就是维护了两种数据结构，一个是被监控文件描述符对象集，一个就绪对象集（ 用户创建提供,epoll自动添加）

- 被监控文件描述符对象集没有放在用户态,不需要频繁在内核和用户态之间拷贝,同时解决了select的1024上限的问题
- 就绪对象集是用户态的,就绪对象集使得不需要完整遍历所有文件描述符

阻塞监控受监控的对象==>有文件读写断开等=>跳出阻塞==>处理==>重新将该文件描述符加入的epoll监控对象==>继续监听

epoll通常需要设置事件触发的模式==>一般默认**就是LT模式**

1. **水平触发（LT）模式**：如文件中有剩余数据,还会接着触发。
   **通常都会用这种模式**，一般会将对应文件描述符设置位非阻塞模式，如果是边缘触发，文件内有剩余数据，会造成延迟读取数据，有时还会造成剩余数据丢失

2. **边缘触发（ET）模式**：如文件中有剩余数据,但是需要新的数据写入才会触发。

   ```c
    event.events = EPOLLIN | EPOLLET | EPOLLRDHUP; // EPOLLET 边缘触发
   ```

   



demo来自知乎:https://zhuanlan.zhihu.com/p/367591714

创建一个客户端,监听是否有连接,有连接则将连接放入监听链表中,同时判断是否断开连接,数据处理

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <cassert>
#include <sys/epoll.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include<iostream>
const int MAX_EVENT_NUMBER = 10000; //最大事件数
// 设置句柄非阻塞
int setnonblocking(int fd)
{
    int old_option = fcntl(fd, F_GETFL);
    int new_option = old_option | O_NONBLOCK;
    fcntl(fd, F_SETFL, new_option);
    return old_option;
}

int main(){

    // 创建套接字
    int nRet=0;
    int m_listenfd = socket(PF_INET, SOCK_STREAM, 0);
    if(m_listenfd<0)
    {
        printf("fail to socket!");
        return -1;
    }
    // 
    struct sockaddr_in address;
    bzero(&address, sizeof(address));
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = htonl(INADDR_ANY);
    address.sin_port = htons(6666);

    int flag = 1;
    // 设置ip可重用
    setsockopt(m_listenfd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(flag));
    // 绑定端口号
    int ret = bind(m_listenfd, (struct sockaddr *)&address, sizeof(address));
    if(ret<0)
    {
        printf("fail to bind!,errno :%d",errno);
        return ret;
    }

    // 监听连接fd
    ret = listen(m_listenfd, 200);
    if(ret<0)
    {
        printf("fail to listen!,errno :%d",errno);
        return ret;
    }

    // 初始化红黑树和事件链表结构rdlist结构
    epoll_event events[MAX_EVENT_NUMBER]; //事件链表
    // 创建epoll实例
    int m_epollfd = epoll_create(5); 
    if(m_epollfd==-1)
    {
        printf("fail to epoll create!");
        return m_epollfd;
    }



    // 创建节点结构体将监听连接句柄
    epoll_event event;
    event.data.fd = m_listenfd;
    //设置该句柄为边缘触发（数据没处理完后续不会再触发事件，水平触发是不管数据有没有触发都返回事件），
    event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;
    // 添加监听连接句柄作为初始节点进入红黑树结构中，该节点后续处理连接的句柄
    epoll_ctl(m_epollfd, EPOLL_CTL_ADD, m_listenfd, &event);

    //进入服务器循环
    while(1)
    {
        int number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, -1);
        if (number < 0 && errno != EINTR)
        {
            printf( "epoll failure");
            break;
        }
        for (int i = 0; i < number; i++)
        {
            int sockfd = events[i].data.fd;
            // 属于处理新到的客户连接
            if (sockfd == m_listenfd)
            {
                struct sockaddr_in client_address;
                socklen_t client_addrlength = sizeof(client_address);
                int connfd = accept(m_listenfd, (struct sockaddr *)&client_address, &client_addrlength);
                if (connfd < 0)
                {
                    printf("errno is:%d accept error", errno);
                    return false;
                }
                epoll_event event;
                event.data.fd = connfd;
                //设置该句柄为边缘触发（数据没处理完后续不会再触发事件，水平触发是不管数据有没有触发都返回事件），
                event.events = EPOLLIN | EPOLLRDHUP;
                // 添加监听连接句柄作为初始节点进入红黑树结构中，该节点后续处理连接的句柄
                epoll_ctl(m_epollfd, EPOLL_CTL_ADD, connfd, &event);
                setnonblocking(connfd); //非阻塞io
            }
            
            // 处理关闭事件
            else if (events[i].events & (EPOLLRDHUP | EPOLLHUP | EPOLLERR))
            {
                //服务器端关闭连接，
                epoll_ctl(m_epollfd, EPOLL_CTL_DEL, sockfd, 0);
                close(sockfd);
            }
            
            //处理客户连接上接收到的数据
            else if (events[i].events & EPOLLIN)
            {
                //读出数据
                char buf[1024]={0};
                read(sockfd,buf,1024);
                printf("from client :%s");

                // 将事件设置为写事件返回数据给客户端,改为监听读事件
                events[i].data.fd = sockfd;
                events[i].events = EPOLLOUT | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;
                epoll_ctl(m_epollfd, EPOLL_CTL_MOD, sockfd, &events[i]);
            }
            else if (events[i].events & EPOLLOUT)
            {
                std::string response = "server response \n";
                write(sockfd,response.c_str(),response.length());

                // 将事件设置为读事件，继续监听客户端
                events[i].data.fd = sockfd;
                events[i].events = EPOLLIN | EPOLLRDHUP;
                epoll_ctl(m_epollfd, EPOLL_CTL_MOD, sockfd, &events[i]);
            }
            //else if 可以加管道，unix套接字等等数据
        }
    }


}
```



## 网络信息相关API ` netdb.h `

#### `gethostname` 函数

- 原型：`int gethostname(char *hostname, size_t size);`
- 功能：获取本地主机名。
- 参数：
  - `hostname`：用于存储主机名的缓冲区。
  - `size`：缓冲区的大小。
- 返回值：
  - 成功时返回0，失败时返回-1，并设置 `errno`。
- 所在头文件：`#include `

#### `getpeername` 函数

- 原型：`int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`
- 功能：获取与套接口 `sockfd` 相连的远程协议地址。
- 参数：
  - `sockfd`：套接字描述符。
  - `addr`：用于存储远程协议地址信息的结构体指针。
  - `addrlen`：指向 `addr` 结构体大小的指针。
- 返回值：
  - 成功时返回0，失败时返回-1，并设置 `errno`。
- 所在头文件：`#include `

#### `getsockname` 函数

- 原型：`int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`
- 功能：获取与套接口 `sockfd` 相关联的本地套接口协议地址。
- 参数：
  - `sockfd`：套接字描述符。
  - `addr`：用于存储本地套接口协议地址信息的结构体指针。
  - `addrlen`：指向 `addr` 结构体大小的指针。
- 返回值：
  - 成功时返回0，失败时返回-1，并设置 `errno`。
- 所在头文件：`#include `

#### `gethostbyname` 函数

- 原型：`struct hostent *gethostbyname(const char *name);`
- 功能：根据主机名获取主机信息。
- 参数：
  - `name`：要查询的主机名。
- 返回值：
  - 成功时返回指向 `hostent` 结构体的指针，失败时返回 `NULL`。
- 所在头文件：`#include `

#### `endhostent 函数

- 原型：`void endhostent(void);`
- 功能：关闭主机数据库（通常在使用 `gethostbyname` 后调用）。
- 参数：无。
- 返回值：无。
- 所在头文件：`#include `

#### `gethostbyaddr` 函数

- 原型：`struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);`
- 功能：根据主机地址取得主机信息。
- 参数：
  - `addr`：指向主机地址的指针。
  - `len`：地址的长度。
  - `type`：地址的类型，通常为 `AF_INET`（IPv4）或 `AF_INET6`（IPv6）。
- 返回值：
  - 成功时返回指向 `hostent` 结构体的指针，失败时返回 `NULL`。
- 所在头文件：`#include `

#### `getprotobyname` 函数

- 原型：`struct protoent *getprotobyname(const char *name);`
- 功能：根据协议名取得主机协议信息。
- 参数：
  - `name`：要查询的协议名，如 "tcp" 或 "udp"。
- 返回值：
  - 成功时返回指向 `protoent` 结构体的指针，失败时返回 `NULL`。
- 所在头文件：`#include `

#### `getprotobynumber` 函数

- 原型：`struct protoent *getprotobynumber(int proto);`
- 功能：根据协议号取得主机协议信息。
- 参数：
  - `proto`：要查询的协议号。
- 返回值：
  - 成功时返回指向 `protoent` 结构体的指针，失败时返回 `NULL`。
- 所在头文件：`#include `

#### `getservbyname` 函数：

- 原型：`struct servent *getservbyname(const char *name, const char *proto);`
- 功能：根据服务名取得相关服务信息。
- 参数：
  - `name`：要查询的服务名，如 "http"。
  - `proto`：服务的协议，如 "tcp" 或 "udp"。
- 返回值：
  - 成功时返回指向 `servent` 结构体的指针，失败时返回 `NULL`。
- 所在头文件：`#include `

#### `getservbyport` 函数

- 原型：`struct servent *getservbyport(int port, const char *proto);`
- 功能：根据端口号取得相关服务信息。
- 参数：
  - `port`：要查询的端口号。
  - `proto`：服务的协议，如 "tcp" 或 "udp"。
- 返回值：
  - 成功时返回指向 `servent` 结构体的指针，失败时返回 `NULL`。
- 所在头文件：`#include `



## 超时检测

方案1:通过setsocketopt函数去设置读和写的时间

```
    struct timeval  tv;
    tv.tv_sec = 5;   //  设置5秒时间
    tv.tv_usec = 0;
    if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO,  &tv, sizeof(tv))){
        perror("setsockopt");
        close(sockfd);
        exit(EXIT_FAILURE);
    }   //  设置接收超时,用recv/recvfrom
    
     if (setsockopt(sockfd, SOL_SOCKET,  SO_SNDTIMEO,  &tv, sizeof(tv))){
        perror("setsockopt");
        close(sockfd);
        exit(EXIT_FAILURE);
    }   //  设置发送超时,用send/sendto
```



方案2:多路io复用设置超时时间



方案3:信号+计时器

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

// 定时器处理函数
void timer_handler(int signum) {
    printf("Timer expired!\n");
}

int main() {
	//---socket初始化
	
	//---
    // 注册信号处理函数
    signal(SIGALRM, timer_handler);

    // 设置定时器，每5秒触发一次

    // 主循环，等待信号
    while (1) {
         alarm(5);
         recv(...);// recv在5s后被信号打断 recv将返回-1，同时设置errno为EINTR（表示被中断）。
    }

    return 0;
}
```





## 广播



广播地址:最大网段为广播网段如192.168.1.0 (255.255.255.0)   ==>最大的主机地址192.168.1.255代表该网段的广播地址  

任何网段中都代表广播底子:255.255.255.255  

发送端:

- 创建udp套接字
- setsockopt设置为广播地址
- 指定本地端口信息然后发送

接收端

- 创建udp套接字
- 接收信息



### 广播发送端

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define BROADCAST_PORT 12345
#define BROADCAST_ADDR "255.255.255.255"
#define MAX_BUFFER_SIZE 1024

int main()
{
    int udp_socket;
    struct sockaddr_in server_addr, client_addr;
    socklen_t server_addr_len = sizeof(server_addr);
    char buffer[MAX_BUFFER_SIZE];

    // Create a UDP socket
    udp_socket = socket(AF_INET, SOCK_DGRAM, 0);
    if (udp_socket == -1)
    {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // Enable broadcast option for the socket
    int broadcast_enable = 1;
    if (setsockopt(udp_socket, SOL_SOCKET, SO_BROADCAST, &broadcast_enable, sizeof(broadcast_enable)) == -1)
    {// 通过set设置为广播发送
        perror("setsockopt");
        close(udp_socket);
        exit(EXIT_FAILURE);
    }

    // Configure server address for broadcasting
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(BROADCAST_ADDR); //设置为广播地址
    server_addr.sin_port = htons(BROADCAST_PORT);

    while (1)
    {
        printf("Enter message to broadcast (or 'exit' to quit): ");
        fgets(buffer, sizeof(buffer), stdin);

        // Remove newline character from the input
        size_t len = strlen(buffer);
        if (len > 0 && buffer[len - 1] == '\n')
        {
            buffer[len - 1] = '\0';
        }

        if (strcmp(buffer, "exit") == 0)
        {
            break;
        }

        // Send the message as a UDP broadcast
        ssize_t bytes_sent = sendto(udp_socket, buffer, strlen(buffer), 0,
                                    (struct sockaddr *)&server_addr, sizeof(server_addr));
        if (bytes_sent == -1)
        {
            perror("sendto");
            close(udp_socket);
            exit(EXIT_FAILURE);
        }

        // Receive response from the server (optional)
        memset(buffer, 0, sizeof(buffer));
        ssize_t bytes_received = recvfrom(udp_socket, buffer, sizeof(buffer), 0,
                                          (struct sockaddr *)&server_addr, &server_addr_len);
        if (bytes_received == -1)
        {
            perror("recvfrom");
        }
        else
        {
            printf("Received response from server: %s\n", buffer);
        }
    }

    close(udp_socket);
    return 0;
}
```



### 广播接收端

接收方需要设置为广播接收

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define BROADCAST_PORT 12345
#define MAX_BUFFER_SIZE 1024

int main()
{
    int udp_socket;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    char buffer[MAX_BUFFER_SIZE];

    // Create a UDP socket
    udp_socket = socket(AF_INET, SOCK_DGRAM, 0); // 普通的UDP
    if (udp_socket == -1)
    {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // Configure server address for receiving broadcasts
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY; // 接收任意ip
    server_addr.sin_port = htons(BROADCAST_PORT);

    // Bind the socket to the server address
    if (bind(udp_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1)
    {
        perror("bind");
        close(udp_socket);
        exit(EXIT_FAILURE);
    }

    printf("UDP Broadcast Server is listening on port %d...\n", BROADCAST_PORT);

    while (1)
    {
        memset(buffer, 0, sizeof(buffer));

        // Receive data from a client
        ssize_t bytes_received = recvfrom(udp_socket, buffer, sizeof(buffer), 0,
                                          (struct sockaddr *)&client_addr, &client_addr_len);

        if (bytes_received == -1)
        {
            perror("recvfrom");
        }
        else
        {
            printf("Received from %s:%d: %s\n", inet_ntoa(client_addr.sin_addr),
                   ntohs(client_addr.sin_port), buffer);

            // Process the received data as needed

            // Send a response to the client
            // (e.g., echo the received message back to the sender)
            ssize_t bytes_sent = sendto(udp_socket, buffer, bytes_received, 0,
                                        (struct sockaddr *)&client_addr, client_addr_len);
            if (bytes_sent == -1)
            {
                perror("sendto");
            }
        }
    }

    close(udp_socket);
    return 0;
}
```



## 多播

 多播（Multicast）是一种网络通信模式，它允许一个发送者将消息发送到多个接收者，这些接收者被组织成一个多播组（Multicast Group）。 



### 组播发送方

创建udp套接字==>向指定组播地址发送信息

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define MULTICAST_GROUP "224.0.0.1"
#define PORT 12345

int main()
{
    int sockfd;
    struct sockaddr_in multicast_addr;
    char message[] = "Hello, Multicast Group!";

    // 创建UDP套接字
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0)
    {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    //这里只发送所有没有进行本地bind,如果有需要接收可以bind一个本地信息
    
    // 发送的多播组信息
    memset(&multicast_addr, 0, sizeof(multicast_addr));
    multicast_addr.sin_family = AF_INET;
    multicast_addr.sin_addr.s_addr = inet_addr(MULTICAST_GROUP);
    multicast_addr.sin_port = htons(PORT);

    while (1)
    {
        // 发送消息到多播组
        if (sendto(sockfd, message, sizeof(message), 0, (struct sockaddr *)&multicast_addr, sizeof(multicast_addr)) < 0)
        {
            perror("sendto");
            exit(EXIT_FAILURE);
        }
        printf("Sent: %s\n", message);
        sleep(2); // 间隔2秒发送一次消息
    }

    // 关闭套接字
    close(sockfd);

    return 0;
}
```





### 组播接收方

创建udp套接字==>加入组播地址==>接收信息

加入多播组的设置的结构体

```c
struct ip_mreq {
    struct in_addr imr_multiaddr;  // 多播组地址
    struct in_addr imr_interface;  // 本地接口地址
};
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/ip.h>
#define MULTICAST_GROUP "224.0.0.1"
#define PORT 12345

int main()
{
    int sockfd;
    struct sockaddr_in multicast_addr;
    struct ip_mreq mreq;
    char buffer[1024];

    // 创建UDP套接字
    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0)
    {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 正常设置接收信息
    memset(&multicast_addr, 0, sizeof(multicast_addr));
    multicast_addr.sin_family = AF_INET;
    multicast_addr.sin_addr.s_addr = htonl(INADDR_ANY); // 接收任意地址
    multicast_addr.sin_port = htons(PORT);

    // 绑定到特定端口
    if (bind(sockfd, (struct sockaddr *)&multicast_addr, sizeof(multicast_addr)) < 0)
    {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    // 加入多播组
    mreq.imr_multiaddr.s_addr = inet_addr(MULTICAST_GROUP);
    mreq.imr_interface.s_addr = htonl(INADDR_ANY);
    //设置为多播
    if (setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0)
    {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }

    while (1)
    {
        // 接收多播消息
        ssize_t recv_len = recvfrom(sockfd, buffer, sizeof(buffer), 0, NULL, 0);
        if (recv_len < 0)
        {
            perror("recvfrom");
            exit(EXIT_FAILURE);
        }
        buffer[recv_len] = '\0';
        printf("Received: %s\n", buffer);
    }

    // 关闭套接字
    close(sockfd);

    return 0;
}
```



## 套接字进程通信



 套接字可以用于本地通信，这通常被称为"Unix 域套接字"或"本地套接字"。本地套接字用于在同一台计算机上的进程之间进行通信，而不涉及网络通信。本地套接字通常用于进程间的 IPC（进程间通信），并且在操作系统中广泛使用。 

使用套接字进行本地通信和网络通信几乎一致==>只要进行简单修改即可

```c
// 创建时使用本地协议PF_UNIX(或PF_LOCAL)。

 socket(AF_LOCAL, SOCK_STREAM, 0); //tcp 更可靠,和tcp编程类似,只是在端口阶段使用了本地唯一文件名称取代
 socket(AF_LOCAL, SOCK_DGRAM,0) ; //udp

// 同时绑定和发送的addr都设定为本地唯一文件名称
  memset(&client_addr, 0, sizeof(client_addr));
  client_addr.sun_family = AF_UNIX;
  strncpy(client_addr.sun_path, "/tmp/client_socket", sizeof(client_addr.sun_path) - 1);

```

进程间通信,常用unix域套接字和共享内存

- 易用性
  消息队列>unix域套接字>管道>共享内存
- 效率
  共享内存>unix域套接字>管道>消息队列



### tcp本地通信

#### 服务端

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/un.h>

#define SOCKET_PATH "/tmp/my_socket"

int main() {
    int sockfd, client_sockfd;
    struct sockaddr_un server_addr, client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    char buffer[1024];

    // 创建套接字
    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 设置本地套接字地址
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sun_family = AF_UNIX;
    strncpy(server_addr.sun_path, SOCKET_PATH, sizeof(server_addr.sun_path) - 1);

    // 绑定套接字到本地地址
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    // 监听连接请求
    if (listen(sockfd, SOMAXCONN) < 0) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    printf("Waiting for a connection...\n");

    // 接受客户端连接请求
    client_sockfd = accept(sockfd, (struct sockaddr *)&client_addr, &client_addr_len);
    if (client_sockfd < 0) {
        perror("accept");
        exit(EXIT_FAILURE);
    }

    printf("Connected to a client\n");

    // 从客户端接收数据
    ssize_t bytes_received = recv(client_sockfd, buffer, sizeof(buffer), 0);
    if (bytes_received < 0) {
        perror("recv");
        exit(EXIT_FAILURE);
    }

    printf("Received data from client: %s\n", buffer);

    // 关闭套接字
    close(client_sockfd);
    close(sockfd);

    // 删除套接字文件
    unlink(SOCKET_PATH);

    return 0;
}
```



#### 客户端

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/un.h>

#define SOCKET_PATH "/tmp/my_socket"

int main() {
    int sockfd;
    struct sockaddr_un server_addr;
    char message[] = "Hello, Server!";

    // 创建套接字
    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sockfd < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 设置服务器端的本地套接字地址
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sun_family = AF_UNIX;
    strncpy(server_addr.sun_path, SOCKET_PATH, sizeof(server_addr.sun_path) - 1);

    // 连接到服务器
    if (connect(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("connect");
        exit(EXIT_FAILURE);
    }

    // 发送数据给服务器
    if (send(sockfd, message, sizeof(message), 0) < 0) {
        perror("send");
        exit(EXIT_FAILURE);
    }

    printf("Sent data to server: %s\n", message);

    // 关闭套接字
    close(sockfd);

    return 0;
}
```



### udp本地通信

#### 发送方

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define SOCKET_PATH "/tmp/local_socket1"

int main()
{
    int sockfd;
    struct sockaddr_un server_addr, client_addr;
    socklen_t server_addr_len = sizeof(server_addr);
    socklen_t client_addr_len = sizeof(client_addr);
    char send_buffer[256];
    char recv_buffer[256];

    // 创建本地套接字
    sockfd = socket(AF_UNIX, SOCK_DGRAM, 0);
    if (sockfd < 0)
    {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 设置本地套接字地址结构
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sun_family = AF_UNIX;
    strncpy(server_addr.sun_path, SOCKET_PATH, sizeof(server_addr.sun_path) - 1);

    // 设置客户端套接字地址结构
    memset(&client_addr, 0, sizeof(client_addr));
    client_addr.sun_family = AF_UNIX;
    strncpy(client_addr.sun_path, "/tmp/client_socket", sizeof(client_addr.sun_path) - 1);

    // 绑定客户端套接字到本地地址
    if (bind(sockfd, (struct sockaddr *)&client_addr, sizeof(client_addr)) < 0)
    {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    while (1)
    {
        // 发送消息到接收方
        const char *message = "Hello from sender!";
        if (sendto(sockfd, message, strlen(message), 0, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
        {
            perror("sendto");
            exit(EXIT_FAILURE);
        }

        printf("Sent: %s\n", message);

        // 接收来自接收方的回复消息
        ssize_t recv_len = recvfrom(sockfd, recv_buffer, sizeof(recv_buffer), 0, (struct sockaddr *)&server_addr, &server_addr_len);
        if (recv_len < 0)
        {
            perror("recvfrom");
            exit(EXIT_FAILURE);
        }

        recv_buffer[recv_len] = '\0';
        printf("Received reply: %s\n", recv_buffer);
        sleep(2);
    }

    // 关闭套接字
    close(sockfd);

    return 0;
}
```



#### 接收方

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define SOCKET_PATH "/tmp/local_socket"

int main()
{
    int sockfd;
    struct sockaddr_un server_addr, client_addr;
    socklen_t server_addr_len = sizeof(server_addr);
    socklen_t client_addr_len = sizeof(client_addr);
    char send_buffer[256];
    char recv_buffer[256];

    // 创建本地套接字
    sockfd = socket(AF_UNIX, SOCK_DGRAM, 0);
    if (sockfd < 0)
    {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // 设置本地套接字地址结构
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sun_family = AF_UNIX;
    strncpy(server_addr.sun_path, SOCKET_PATH, sizeof(server_addr.sun_path) - 1);

    // 设置客户端套接字地址结构
    memset(&client_addr, 0, sizeof(client_addr));
    client_addr.sun_family = AF_UNIX;
    strncpy(client_addr.sun_path, "/tmp/client_socket", sizeof(client_addr.sun_path) - 1);

    // 绑定服务器套接字到本地地址
    if (bind(sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    while (1)
    {
        // 接收来自发送方的消息
        ssize_t recv_len = recvfrom(sockfd, recv_buffer, sizeof(recv_buffer), 0, (struct sockaddr *)&client_addr, &client_addr_len);
        if (recv_len < 0)
        {
            perror("recvfrom");
            exit(EXIT_FAILURE);
        }

        recv_buffer[recv_len] = '\0';
        printf("Received message: %s\n", recv_buffer);

        // 发送回复消息给发送方
        const char *reply_message = "Hello from receiver!";
        if (sendto(sockfd, reply_message, strlen(reply_message), 0, (struct sockaddr *)&client_addr, client_addr_len) < 0)
        {
            perror("sendto");
            exit(EXIT_FAILURE);
        }

        printf("Sent reply: %s\n", reply_message);
    }
    
    
    // 关闭套接字
    close(sockfd);

    return 0;
}
```



